.. Copyright (C) 2019 Tomas Brabec
.. 
.. 本文档采用知识共享署名4.0国际许可协议授权
.. (cc-by-4.0, http://creativecommons.org/licenses/by/4.0/).

静态时序分析基础
================

本作品采用`知识共享署名4.0国际许可协议 <http://creativecommons.org/licenses/by/4.0/>`_授权 |cc_by_40_logo|。

.. |cc_by_40_logo| image:: https://i.creativecommons.org/l/by/4.0/88x31.png
  :alt: CC BY 4.0

.. contents::

简介
----

本节为从静态时序分析的角度理解数字电路奠定基础，有信心的读者可以直接跳转到`静态时序分析`_章节。

数字电路
........

数字电路可以通过两个方面来表征，我们将在下面进一步讨论：

- 对时钟敏感（包含同步性的前提）
- 从某些物理层面进行抽象（包含使用二进制逻辑）

存在一个平滑的、（通常）固定已知频率的时钟是数字设计的基本前提。从已知频率我们可以综合出电路功能的粗粒度时序，我们使用时钟事件来转换电路状态、响应输入和更新输出。这本质上将数字电路视为一个状态机，其中时序元件保存状态，组合元件定义状态相关的功能。

.. figure:: png/generic_digital_circuit.png

   数字电路的通用结构。

更高层次的抽象提高了大规模数字电路所需的工程师生产力。以下是使用中的一些抽象示例：

- 二进制逻辑：用0、1以及偶尔的高阻态和未知值（X）进行思考简化了功能推理。这里我们从实际的电压电平、阈值电压以及从一个逻辑状态到另一个逻辑状态的变化永远不是离散的这一事实中进行抽象。

- 同步性：当我们理想化时钟时，我们假设数字电路是完全同步的（或在存在多个异步时钟时是多同步的）。同步性的前提让我们可以忽略现实世界中确实存在的许多物理方面（例如组合电路中的动态冒险、时序连续性和亚稳态等）。
  
.. TBD example of dynamic hazards in cb + /c/a when a=0, b=1 and c=1->0 (we do not care as long as dynamic behavior settles by the end of clock period)
  
- 最低层级的门：电路设计视角在逻辑门处停止。数字设计师很少需要从晶体管和其他存在于硅片上的电路元件的角度来思考。与使用二进制逻辑类似，门级抽象简化了对电路功能的推理。

- 静态时序分析通过用最小/最大值限定每个延迟，从信号延迟的连续频谱中进行抽象，然后考虑最快和最慢的时序路径来构建一个保守的、最坏情况下的时序模型。
  
  静态时序还通过将时序路径终止在时序元件的边界来简化分析，因此假设只有从源触发器到目的触发器的路径，中间只有组合逻辑。这将整个系统时序抽象为对孤立的、离散的触发器到触发器路径的分析。

本次讨论的唯一目的是让你理解静态时序分析是一组巧妙的简化，将电路时序过度复杂的现实缩小为一个枯燥的数学练习。然而这些简化足够保守（有时过于保守）以保证电路的正确功能，至少在其时序方面。

触发器
......

虽然在分立设计实践中存在许多类型的时序门，但在数字设计中我们只限制使用两种类型：D锁存器和D触发器。这源于用HDL语言描述数字电路的期望以及可以从这种描述中提取的语义。

*D型锁存器*（或简称*D锁存器*）是一种具有透明态和稳定态的时序元件，由*门控*信号``G``（或反相*使能*）控制。在透明态下，锁存器持续将数据输入``D``传播到数据输出``Q``。在稳定态下，数据输出保持门"关闭"之前最后一个数据输入值。下图显示了D锁存器操作的示例；为简单起见，我们忽略了任何传播延迟。

.. figure:: png/d_latch.png

   D型锁存器（原理图、符号和示例波形）。

D锁存器功能可以用以下HDL代码描述。

.. code-block:: SystemVerilog

  // Verilog语法
  always @(D or G) begin
      if (G)
          Q <= D;
  end
  
  // SystemVerilog语法
  always_latch begin
      if (G)
          Q <= D;
  end

锁存器的问题在于透明模式。从``Q``到``D``的反相组合环路在透明模式下将以与该环路累积传播延迟成比例的频率开始振荡（见下图）。此外，透明模式下的锁存器序列将创建一个跨越一个或多个时序元件的组合（或异步）路径。因此，使用D锁存器需要仔细的设计实践，其中后续锁存器级使用相互反相的门控信号，并且禁止到同一级锁存器的组合路径（包括环路）。

.. figure:: png/latch_oscillator.png

   由于通过锁存器的反相反馈导致的振荡。

*D型触发器*（或简称*D触发器*、*FF*或简称*触发器*）是一种时序元件，其中数据输入``D``在时钟信号``CK``的上升沿事件时复制到数据输出``Q``。其实现通常构建在一系列D锁存器上，称为*主*锁存器和*从*锁存器，具有反相的门控控制，使得每个``CK``半周期只有一个锁存器是透明的，另一个是稳定的。因此，时钟在*有效沿*方向的转换将数据从输入"倾倒"到输出并将其"锁定"在那里，直到下一个时钟有效沿。FF功能（忽略门延迟）和等效HDL代码如下所示。

.. figure:: png/d_flop.png

   D型触发器（原理图、符号和示例波形）。

.. code-block:: SystemVerilog

    // SystemVerilog语法（Verilog只会使用`always @(...)`）
    always_ff @(posedge CK) begin
        Q <= D;
    end

触发器在单个独特时刻*捕获*输入值的事实使得触发器的使用极其简单。组合环路不再重要，我们可以无限制地连接触发器。因此*触发器构成了时钟敏感同步设计的基础*。

触发器时序参数
................

与其他门一样，触发器由具有非零响应时间的晶体管构建。这使得触发器经历捕获输入数据并将其发布到数据输出所需的延迟。这些延迟引出了三个核心时序参数：*传播延迟*、*建立时间*和*保持时间*。

.. figure:: png/flop_timing_waveform.png

   显示核心触发器时序参数的波形图。

传播时间（Tp）
  这是从时钟有效沿到捕获的数据出现在数据输出上的时间。

建立时间（Ts）
  这是时钟有效沿之前数据输入需要稳定的最新时间，以便被可靠捕获。

保持时间（Th）
  这是时钟有效沿之后数据输入需要保持稳定的最短时间，以便被可靠捕获。

传播时间与从锁存器在时钟沿后变为透明时的延迟有关。建立时间和保持时间与稳定主锁存器结构有关，因此对触发器的正确功能至关重要。

换句话说，建立时间和保持时间定义了时钟有效沿周围数据输入必须绝对稳定的窗口。违反此要求可能导致意外情况，即数据输入未被捕获（即数据输出保持其先前的值），或者更糟的是，可能变得亚稳态（见`亚稳态`_）。因此，建立时间和保持时间要求奠定了数字电路时序的基础，如果我们过度简化，它们是静态时序分析的唯一目的。

.. mention reset removal and recovery as an equivalent to setup/hold

亚稳态
......

亚稳态是一个微妙而复杂的主题，要充分理解它，请务必阅读[Golson2014]_。我们这里的描述是简化的，以便读者理解它对时序假设的影响。

在详细讨论之前，将静态时序分析视为一种检查数据从源触发器到目的触发器的方法，该数据在保持时间之后足够晚到达，但在目的触发器的建立时间之前足够早到达。此检查计算信号通过源和目的之间所有门所需的时间，此时间包括源触发器的传播时间。

在正常条件下，翻转源触发器的输出从一个逻辑电平到另一个逻辑电平需要其传播时间Tp。当源触发器的建立时间或保持时间被违反时，该触发器可能进入*亚稳态*。在此状态下，触发器的内部电路（即其主锁存器或从锁存器的反相器环路）在逻辑电平之间翻转时，在稳定边缘停止，其下一个状态无法预测；它将要么完成翻转，要么回落到先前的逻辑状态。另一个麻烦方面是最终状态解析将花费比传播时间更长的时间，而且，该时间无法预测。

为了帮助你更好地想象正在发生的事情，将下图视为触发器的机械类比：一个球和一座山（来源[Golson2014]_，归功于[Wakerly87]_）。在山的两侧，球处于稳定状态，左或右，逻辑0或逻辑1。翻转触发器就像将球"踢"上山。在建立/保持窗口之外稳定触发器的输入就像踢得足够用力让球越过山顶并落在另一侧，处于另一个逻辑状态。当进入建立/保持窗口并接近时钟沿时，踢的强度降低；接近时钟沿时，踢的力度太弱，球甚至无法到达顶部（即落回原来的位置，触发器不会翻转）。在两者之间，会有一个踢的强度使球到达山顶并在那里保持平衡，直到它最终落在一侧或另一侧；这模拟了亚稳态事件。正如你可以想象的，球可能会在那里保持平衡很长时间；肯定比用"强"的、翻转的踢要长。

.. figure:: png/metastability_mechanical_analogy.png

   亚稳态机械类比（[Golson2014]_和[Wakerly87]_）。

下图（来源[Golson2014]_，归功于[ChaneyMolnar73]_）显示了亚稳态在实践中如何在触发器的输出``Q``（及其反相``/Q``）处呈现。模糊区域显示了许多解析及其花费的时间。

.. figure:: png/metastability_flop_output_trace.png

   亚稳态触发器输出的示波器迹线（[Golson2014]_和[ChaneyMolnar73]_）。

现在我们解释亚稳态和建立/保持时间究竟如何相互关联。下图显示了一个图，其中水平轴表示触发器的时钟和数据输入变化之间的时间；左侧数据输入变化先于时钟事件，右侧则相反。垂直轴表示翻转触发器所需的时间。在足够远的左侧和右侧，``Q``输出以恒定延迟翻转。我们让数据变化越接近时钟事件（即越接近原点0处的图），翻转所需的时间就越长，直到达到某些翻转永远不会发生的界限（即垂直渐近线之间的"数据未被捕获"区域）。接近渐近线时，翻转时间呈指数增长，你可能已经猜到渐近线代表亚稳态。

.. figure:: png/flop_characterization_plot.png

   触发器传播时间作为数据和时钟输入变化之间时间延迟的函数。

在表征触发器的时序参数时，运行仿真以确定类似的图。``CK``到``Q``时间被限制在其最低值的某个百分比（例如加10%），这就成为了传播时间。图与传播限制相交处的``CK``到``D``时间成为建立/保持时间（左/右）。如你所见，建立时间和保持时间被设置在一定余量之外，远离实际的亚稳态区域，这就是为什么它们保证在建立/保持稳定窗口之外的正确功能。你可能还会注意到，除非你的设计将处于建立/保持时间的边缘，否则实际触发器的传播延迟将少于表征的传播时间。

为了结束这个简短的题外话，请记住以下几点：

- 触发器的时序参数被确定为足够小或足够大以避免亚稳态。
- 将``D``输入更改得离时钟有效沿太近，使得建立时间或保持时间被违反

  a. 可能导致触发器的下一个逻辑状态不可预测，以及
  b. 将导致到``Q``的传播延迟超过传播时间（从而使静态时序分析的假设失效）。

.. note:: 选择用一组离散时序参数来表示和约束触发器的翻转功能是数字设计为简化其任务而采取的抽象之一。如你所知，时序参数是保守推导的，因此没有静态时序违规的设计应该处于保证正确操作的安全方面。

静态时序分析
------------

*静态时序分析*（STA）的目标是确保设计中所有触发器（或一般时序元件）都能安全地捕获其数据。或者换句话说，STA确保电路将正确执行其功能（但它不说明该功能的正确性；为此有逻辑仿真）。

术语
....

理解STA中使用的术语对于理解STA本身至关重要。我们从解释基本术语开始；其他的将在我们进行更高级时序方面时介绍。在解释术语的同时，我们也建立了STA概念的基础。

单元、门、网络
  *单元*或*门*是电路中的组合或时序逻辑元件。电路中的单元通过导线/*网络*连接。

时序弧、单元弧、网络弧
  *时序弧*是与逻辑元件/门或网络/导线延迟相关的时序参数。门的时序参数，*单元弧*，来自该门功能的时序表征（例如，参见`亚稳态`_了解触发器表征的示例）。
  网络延迟，*网络弧*，表示信号从驱动器传播到由该网络连接的接收器所需的时间。它是信号*转换速率*和该网络的RC参数（包括网络上所有接收器的电容）的函数。
  
  *单元弧*与该门的输入-输出和/或输入-输入对相关联。输入-输出对弧通常表示从该输入到该输出的信号传播延迟（例如，触发器的Tp说明时钟沿后下一个触发器状态出现在输出上需要多长时间）。输入-输入对弧通常表示与这些输入相关的*时序约束*（例如，触发器的Ts约束时钟沿前数据输入稳定的最晚时间）。并非所有输入-输入和输入-输出对都需要与时序弧相关联；关联产生于该门的功能。
  
.. figure:: png/cell_arcs.png

   触发器（包括由于异步复位``RB``导致的额外弧）和组合单元的单元弧示例。

信号路径
  从一个*单元*到另一个*单元*的*信号路径*是通过*网络*和其他*单元*的朝向逻辑信号传播方向的唯一路径。

时序路径
  *时序路径*是从*起点*到*终点*的一组信号路径，见下图。
  路径朝向逻辑信号可以走的方向（即沿着路径通过逻辑元件的输入到输出）。
  
  设计中的并非每个点都可以是*起点*或*终点*（见后文）。因此，设计中*时序路径*的集合是有限的。通常*时序路径*在时序元件中开始和结束，并且只通过组合逻辑。
  
  *时序路径*可以分解为一系列*时序弧*，路径延迟成为这些弧的总和。
  
  对于给定的一对*起点*和*终点*，因此*时序路径*，可以有多个*信号路径*，逻辑信号可以通过这些路径传播。这是由沿着该路径的逻辑元件的并行时序弧的信号潜在分支和重新组合引起的。
    
  对于每个*时序路径*，STA引擎找到最快（*早*）和最慢（*晚*）的传播延迟。对于给定的*时序路径*，*早*和*晚*路径可以是相同或不同的信号路径。

.. figure:: png/timing_path.png

   分解为时序弧的时序路径示例。

.. figure:: png/parallel_timing_paths.png

   时序路径的并行信号路径示例。

路径类型
  我们可以根据不同的属性对*时序路径*进行分类，例如沿路径传播的信号类型或路径产生的*时序检查*，或路径之间的设计元件。你可能会遇到以下分类：
  
  - 按信号类型或时序检查：*数据路径*、*时钟路径*、*时钟门控路径*、*异步路径*。
  
    - *数据路径*在时序元件的同步数据输入处结束。数据路径用于*建立/保持检查*或等效的*时序检查*。
      
    - *时钟路径*在触发器的时钟输入处结束。时钟路径不是我们将直接执行*时序检查*的*时序路径*；它用作检查其他路径类型的补充路径。
      
    - *时钟门控路径*在时钟门控*单元*处结束，用于时钟门控建立和保持检查。
      
    - *异步路径*在触发器的异步输入（如置位或清零/复位）处结束。
    
  - 按路径点：*输入到寄存器*、*寄存器到寄存器*、*寄存器到输出*、*输入到输出*。
    
    这种分类对于*数据路径*最常见，因为它们在电路中产生大多数时序检查。

.. figure:: png/signal_type_paths.png

   按信号或时序检查类型划分的路径类型。

起点、终点
  *起点*和*终点*是电路中信号变化开始和结束的点。"变化结束"被认为在当前时钟周期内消耗信号变化。显然，*时序路径*的*起点*到*终点*之间必须存在*信号路径*。
  
  *起点*可以是主输入端口或时序元件的时钟引脚。
  
  *终点*可以是主输出端口或时序元件的数据输入。

.. figure:: png/datapath_types.png

   不同类型的数据路径、起点和终点。

从、到、经过
  在指定*时序路径*时，我们使用电路中路径经过的点的标识。因此*从*和*到*标识路径的*起点*和*终点*，*经过*用于标识中间点。点可以是引脚名或单元名（或有时是层次块名），只要它能唯一标识路径；使用引脚是最具体的标识。
  
  *从*和*到*用于标识单个路径或一组路径。*经过*通常用于在多个并行*信号路径*中选择一个。这些说明符通常用于STA工具报告时序或指定高级时序约束。

.. figure:: png/from-through-to_points.png

   *从*、*经过*和*到*点的图示。
  
发射时钟、捕获时钟
  *发射时钟*是在*时序路径*的*起点*启动/*发射*信号变化的时钟源。
  
  *捕获时钟*是在*时序路径*的*终点*采样/*捕获*信号变化的时钟源。
  
  对于给定的*时序路径*，*发射*和*捕获时钟*可以有相同或不同的来源。至于产生数据*发射*和*捕获*的时钟有效沿，这些可能是相同的，也可能是不同的。

.. examples of launch/capture clocks in figures

路径延迟
  *路径延迟*就是沿该路径的*时序弧*延迟的总和。对于信号路径，弧的序列是唯一的。*时序路径*延迟是其信号路径之一的延迟，由我们分析的属性选择（例如*早*或*晚*路径）。
  
  *单元延迟*通常是输入信号转换/转换速率和单元输出负载的函数。*网络延迟*是RC参数的函数。因此路径延迟通常基于相同的参数而变化。

约束
  *时序约束*驱动静态时序分析，因为它们标识电路时序被认为正确的边界。约束来自两个来源：来自技术库和来自用户。
  
  技术约束，如建立/保持时间、最小脉冲宽度、最大电容或最大转换速率，在库单元表征期间确定。这些约束被视为特定技术和单元库的给定条件。
  
  用户定义的约束定义用户对电路时序的假设，包括时钟周期、时钟波形、为电路输入和输出定义的边距及其驱动和负载特性。用户约束通常定义某些时序例外（例如应被分析忽略的信号常数或设计部分）并建模实际系统中通常发生的时序变化（例如时钟抖动或片上参数变化）。
  
  用户还可以覆盖技术库中的约束，用于调试目的或建模某些高度特定的方面。有时其他工具用于确定单元特定约束或网络延迟，其结果以标准化格式回注到时序分析下的电路。

时序检查、建立检查、保持检查
  *时序检查*是静态时序分析的核心，检查给定的*时序路径*是否满足与之相关的所有*约束*。例如，从一个触发器到另一个触发器的数据路径被检查为具有不违反目标触发器建立/保持时间的传播延迟。
  
  事实上，建立和保持检查是STA中最频繁的检查。其他检查验证时钟和复位输入的最小脉冲宽度、异步置位/清零输入的恢复和移除时间、数据到数据时序等。某些检查不一定涉及时序，例如单元最大负载。
  
  *建立检查*和*保持检查*强制执行时序单元的数据建立和保持。*建立检查*测试数据是否在*捕获时钟*有效沿之前足够早到达，不违反捕获元件的建立时间。类似地，*保持检查*测试数据是否在*捕获时钟*有效沿之后足够长时间保持变化，不违反捕获元件的保持时间。见下图。
  
  建立和保持检查是核心的*时序检查*，要测试的许多其他时序方面被转换为这两个检查（例如最小/最大数据延迟）。

.. figure:: png/setup_hold_checks.png

   建立和保持检查的原理。注意每个检查考虑发射和捕获时序的最坏情况组合。

数据到达、数据要求
  如果你考虑一个*寄存器到寄存器*时序路径，那么*数据到达*是从发射触发器的数据变化到达捕获触发器输入的时间。*数据要求*是*捕获时钟*沿到达捕获触发器时钟输入的时间，针对该触发器的数据*时序约束*进行调整（即建立或保持时间）。
  
  由于数据变化由*发射时钟*触发，*数据到达*时间由*发射时钟*传播到发射触发器时钟输入的延迟和触发器到触发器数据传播延迟组成。在上图中，*数据到达*是五个时序弧的总和，三个*网络弧*（td1、td3、td5）和两个*单元弧*（td2、td4）。
  
  数据捕获由*捕获时钟*触发，因此由该时钟传播时间（tc2）表示。可靠捕获受建立/保持时间（tc2）[#]_的约束，因此这些弧必须被计入（减去/加上）以获得最晚/最早的*要求*数据到达。回想*建立检查*；它测试从一个时钟沿到另一个时钟沿的数据传播，因此其*数据要求*也计入时钟周期。*保持检查*是在相同时钟沿之间，因此没有周期时间。
  
  *数据到达*和*数据要求*建立了时序检查的条件：对于*建立检查*，数据应更早到达，对于*保持检查*，它应更晚到达（比*要求*的）。然而，还有更多内容。由于各种原因，*数据*和*时钟路径*上的延迟会波动[#]_。STA需要保守，因此它使用产生最坏情况的*早*和*晚*路径的此类组合。因此*建立检查*比较*晚*数据到达和*早*数据要求，反之亦然对于*保持检查*。
  
  现在从*寄存器到寄存器*路径类型中抽象出来，你可以为*起点*和*终点*的任何组合定义*到达*和*要求*时间。你还可以将该概念推广到任何类型的时钟触发*时序检查*，如恢复/移除或最小/最大路径延迟。
  
.. [#] 注意图中的弧方向表示该弧是加/减（相同/相反方向）到总路径延迟。
    
.. [#] 你将在后面的练习中看到。*起点*和*终点*之间可以有多个并行*信号路径*，每个具有不同的延迟。*单元弧*延迟可能随信号极性变化。可能有时钟不确定性、信号转换速率变化等。
  
余量
  *余量*是避免违反*约束*的时间量。
  
  在*时序检查*计算中，余量通常计算为*数据要求*时间减去*数据到达*时间（即``余量 = T要求 - T到达``）。在保持检查的情况下，当满足保持约束时，这个差值将为负（见上图）。然而，根据其定义，负*余量*表示违规，因此保持余量报告为余量公式结果的负值。

示例
....

本节用于练习整个`术语`_章节中介绍的STA基础知识。它由一系列复杂度递增的练习组成（就STA概念而言）。建议你先自己尝试练习，然后再阅读有文档记录的解决方案。

在每个练习中，目标和任务以*斜体*排版。解决方案和其他评论以正常字体排版。

在所有练习中，我们**将网络视为理想**的，因此忽略其延迟。

练习1：简单的触发器到触发器路径
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*目标：练习建立和保持检查的计算。介绍到达时间和要求时间计算的典型列表。*

.. figure:: png/circ01.png

   练习1电路。

*任务：对于图中FF1到FF2的时序路径，执行以下操作：*

- *识别FF1到FF2时序路径的起点和终点。*
- *计算发射和捕获时钟时序。*
- *计算建立和保持余量。*

根据定义，起点是``FF1/CK``，终点是``FF2/D``。发射和捕获时钟是``FF1/CK``和``FF2/CK``，都源自``clk``。时钟周期为20纳秒，默认时钟波形如下图所示。由此，建立和保持发射沿在时间``T=0纳秒``。建立检查测试数据是否比下一个捕获沿更早到达，因此建立捕获沿在``T=Tclk=20纳秒``。保持检查测试数据是否比相同的捕获沿更晚到达，因此保持捕获沿在``T=0纳秒``。

.. figure:: png/default_same_edge_timing.png

   显示默认发射和捕获时序。

现在对于余量，我们需要确定*数据到达*和*数据要求*时间并计算它们的差值。我们通常以表格形式显示计算，使得*到达*在前，*要求*在后；*余量*出现在最后。我们使用三列：时序点、延迟增量和总延迟。时序点标识其时序弧的值暗示延迟增量。总延迟只是沿路径累积增量。

对于我们的示例，建立余量计算如下：

    点               增量   总计
    clk（上升）          0        0
    FF1/CK              3        3
    G1/A                2        5
    FF2/D               0        5
    数据到达                  5
    
    clk（上升）          0       20
    FF2/CK              0       20
    FF2建立          -0.7     19.3
    数据要求               19.3
    
    余量（要求 - 到达）   14.3 > 0  => 建立检查通过

类似地，对于保持余量：

    点               增量   总计
    clk（上升）          0        0
    FF1/CK              3        3
    G1/A                2        5
    FF2/D               0        5
    数据到达                  5
    
    clk（上升）          0        0
    FF2/CK              0        0
    FF2保持            0.3      0.3
    数据要求                0.3
    
    余量（要求 - 到达）   -4.7 < 0  => 保持检查通过

练习2：负沿时钟触发的影响
~~~~~~~~~~~~~~~~~~~~~~~~~~

*目标：讨论并展示在时序路径中混合具有不同边沿灵敏度的触发器的效果。*

.. figure:: png/circ02.png

   练习2电路。

*任务：对于FF1到FF2的时序路径，执行以下操作：*

- *计算发射和捕获时钟时序。*
- *计算建立和保持余量。*

与`练习1：简单的触发器到触发器路径`_的唯一区别是FF2在下降沿触发。这影响*发射时间*和*捕获时间*。对于*建立检查*，数据在``FF1/CK``上升沿发射，在下一个``FF2/CK``下降沿捕获。因此，对于发射时间``T=0纳秒``，捕获时间是``T=10纳秒``。

::

    点               增量   总计
    clk（上升）          0        0
    FF1/CK              3        3
    G1/A                2        5
    FF2/D               0        5
    数据到达                  5
    
    clk（下降）          0       10
    FF2/CK              0       10
    FF2建立          -0.7      9.3
    数据要求                9.3
    
    余量（要求 - 到达）    4.3 > 0  => 建立检查通过

对于保持检查，我们测试由``FF1/CK``上升沿发射的数据是否被最接近的前一个捕获时钟（即``FF2/CK``下降沿）捕获。因此，对于``T=0纳秒``的发射，最接近的前一个捕获将是``T=-10纳秒``。STA避免发射和捕获时序中的负值，因此我们通过一个时钟周期移位设置，得到``T=20纳秒``和``T=10纳秒``的发射和捕获。

::

    点               增量   总计
    clk（上升）          0       20
    FF1/CK              3       23
    G1/A                2       25
    FF2/D               0       25
    数据到达                 25
    
    clk（上升）          0       10
    FF2/CK              0       10
    FF2保持            0.3     10.3
    数据要求               10.3
    
    余量（要求 - 到达）  -14.7 < 0  => 保持检查通过

现在考虑相反的情况，当发射时钟在下降沿触发而捕获时钟在上升沿触发时。发射/捕获时间将如何变化？建立/保持余量将如何变化？下图将这两种情况进行了对比。

.. note:: 在连续触发器级中混合相反边沿触发的触发器有助于以增加建立时序余量为代价来增加保持时序余量。这种技术通常见于通常不使用STA技术（典型于相同边沿数字设计）的模拟设计师。它在串行接口协议（例如I2C、SPI、JTAG）中也很常见。这种做法的重要性将在`练习4：并行触发器到触发器路径`_中解释。

.. figure:: png/opposite_edge_timing.png

   显示相反边沿触发触发器对建立和保持检查的影响。

练习3：带时钟树的简单触发器到触发器路径
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*目标：练习时钟路径中存在单元时的建立/保持余量计算。思考修复时序违规的可能性。*

.. figure:: png/circ03.png

   练习3电路。

*任务：对于FF1到FF2的时序路径，执行以下操作：*

- *计算发射和捕获时钟时序。*
- *计算建立和保持余量。*
- *思考当G1/A为恒定逻辑0时的情况。*

在之前的练习中，我们使用了没有时钟传播延迟的*理想时钟*。在大多数电路中，时钟信号负载很重，在时钟路径段中插入缓冲器（以防止最大电容违规），创建我们称为*时钟树*的树状结构。
插入时钟树会引入时钟路径延迟，并使时钟事件在不同时间到达不同的触发器。我们称这种差异为*时钟偏斜*。大的时钟偏斜可能是时序违规的一个来源。

在我们的示例中，时钟树中的缓冲器影响发射/捕获时序和最终余量，如下所示：

    # 建立余量计算                               # 保持余量计算
    点               增量   总计                          点               增量   总计
    clk（上升）          0        0                          clk（上升）          0        0
    B1/A                1        1                          B1/A                1        1
    B2/A                2        3   <-- 发射时间 -->    B2/A                2        3
    FF1/CK              3        6                          FF1/CK              3        6
    G1/B                2        8                          G1/B                2        8
    G2/A                2       10                          G2/A                2       10
    FF2/D               0       10                          FF2/D               0       10
    数据到达                 10                          数据到达                 10
    
    clk（上升）          0        7                          clk（上升）          0        0
    B1/A                1        8                          B1/A                1        1
    B3/A                2       10   <-- 捕获时间 -->   B3/A                2        3
    FF2/CK              0       10                          FF2/CK              0        3
    FF2建立          -0.7      9.3                        FF2保持            0.3      3.3
    数据要求                9.3                        数据要求                3.3
    
    余量（要求 - 到达）   -0.7 < 0（！！！）              余量（要求 - 到达）   -6.7 < 0
    => 建立检查失败                                   => 保持检查通过

如我们所见，电路经历了建立时间违规。以下是我们修复它的方法；由于我们缺少0.7纳秒的建立时间，并且在保持上有额外的6.7纳秒余量，理论上修复是可能的。

- 通过以下一种或组合来减少*数据到达*时间，

  - 减少发射时钟延迟（例如移除B2缓冲器；注意移除B1没有帮助，因为它也出现在*要求*路径中），或
  - 减少数据路径延迟（例如通过移除G2并将G1更改为与门）和/或选择更快的单元（包括FF1）。
    
- 通过以下方式增加*数据要求*时间

  - 增加对*到达*时钟路径唯一的时钟路径段的延迟（例如在B2后添加更多时钟缓冲器），或
  - 减少捕获触发器FF2的建立时间（即选择更快的单元），或
  - 增加周期时间（例如选择``Tclk=8纳秒``将使建立余量为0.3纳秒）。

从上述选项中，通过单元缩放或优化组合逻辑（或应用其他重定时技术）来减少数据路径延迟是首选方法。操作时钟路径更加复杂，因为它可能负面影响*到*FF1和*从*FF2的路径的时序；因此，在不知道其时序余量的情况下，我们无法确定不会引入比解决的问题更多的问题。

.. note:: 重要的是要理解，如果所有其他方法都失败了，你总是可以通过放宽周期时间来修复建立时间违规。

到目前为止，我们考虑了``G1/A``由某些任意逻辑驱动。当我们有恒定的``G1/A=0``时，情况会如何变化？

显然，G1是与非门，因此其输出将变为恒定``G1/Y=1``，该恒定最终将传播到``FF2/D``。从时序角度来看，路径将变为恒定，因此成为*无效路径*。

练习4：并行触发器到触发器路径
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*目标：练习在从起点到终点存在多条路径的情况下的时序分析。思考修复时序违规的可能性。*

.. figure:: png/circ04.png

   练习4电路。

*任务：对于FF1到FF2的时序路径，执行以下操作：*

- *计算发射和捕获时钟时序。*
- *计算建立和保持余量。*

此示例的新方面是存在从``FF1/CK``到``FF2/D``的多条数据路径，我们需要确定*最晚*和*最早*的路径。在我们案例的两条路径中，通过G1的路径显然比通过G2的路径更长。因此我们使用前者进行建立检查，使用后者进行保持检查。

::

    # 建立余量计算                               # 保持余量计算
    点               增量   总计                          点               增量   总计
    clk（上升）          0        0   <-- 发射时间 -->    clk（上升）          0        0
    FF1/CK              3        3                          FF1/CK              3        3
    G1/B                2        5                          G2/A                1        4
    G3/A                2        7                          G2/B                2        6
    FF2/D               0        7                          FF2/D               0        6
    数据到达                  7                          数据到达                  6
    
    clk（上升）          0        2                          clk（上升）          0        0
    B1/A                2        4                          B1/A                2        2
    B2/A                2        6                          B2/A                2        4
    B3/A                2        8   <-- 捕获时间 -->   B3/A                2        6
    FF2/CK              0        8                          FF2/CK              0        6
    FF2建立          -0.7      7.3                        FF2保持            0.3      6.3
    数据要求                7.3                        数据要求                6.3
    
    余量（要求 - 到达）    0.3 > 0                    余量（要求 - 到达）    0.3 > 0（！！！）
    => 建立检查通过                                   => 保持检查失败

与之前的练习一样，我们经历了时序违规，这次是在保持上。修复选项如下：

- 通过以下方式增加*数据到达*时间

  - 增加对*发射时钟*路径唯一的时钟路径段的延迟，或
  - 增加数据路径延迟（例如通过插入新的缓冲器或缩放现有路径单元）。

- 通过以下方式减少*数据要求*时间

  - 减少时钟路径段对*捕获时钟*路径唯一的延迟（例如移除或缩放某些时钟缓冲器），或
  - 减少捕获触发器FF2的保持时间（例如通过选择不同的FF单元）。

与建立违规一样，修复数据路径是首选；这里我们可以在通过G2的路径中插入1纳秒的缓冲器。操作时序路径可能负面影响到FF1和从FF2的时序路径；此外在我们的情况下，我们似乎没有足够的建立余量。

.. note:: 注意，对于相同边沿的寄存器到寄存器路径，*数据要求*时钟路径不包括周期时间，时序违规与放宽时钟周期无关。这就是为什么**保持违规比建立违规更严重**。
   
   现在如果你考虑`练习2：负沿时钟触发的影响`_中关于像I2C这样的串行接口使用不同时钟边沿来驱动和捕获数据的注释。这种做法将周期时间引入建立和保持检查计算中。然后有机会通过改变周期时间和/或占空比来修复两侧的时序。

练习5：小型电路分析
~~~~~~~~~~~~~~~~~~~~

*目标：在具有多条路径和不同类型路径的完整电路中练习时序分析。*

.. figure:: png/circ05.png

   练习5电路。

*任务：对于给定的电路，执行以下操作：*

- *识别所有有效的时序路径。*
- *识别关键路径并计算最坏建立和保持余量。*

所有之前的练习都明确了什么是时序路径；而且，到目前为止分析的所有路径都是寄存器到寄存器的。在完整电路中，会有不同触发器之间的不同路径，以及到/从电路主端口的路径。所有这些路径都需要分析，最坏余量需要考虑用于评估STA的成功或失败。

在本练习中引入主输入和输出只是为了迷惑你。除非你有关于其时序的信息，否则你必须忽略它们。因此，我们这里的任务简化为仅分析*寄存器到寄存器*路径。下表总结了所有存在的路径及其建立/保持余量。

======== ========== ================== =================
  从       到        建立余量 [纳秒]   保持余量 [纳秒]    
======== ========== ================== =================
 FF1/CK   FF3/D       6.3                -2.7
 FF1/CK   FF4/D       7.3                -1.7
 FF2/CK   FF3/D       2.3                -6.7
 FF3/CK   FF4/D       6.3                -2.7
======== ========== ================== =================

建立和保持检查余量最小的路径分别是FF2到FF3和FF1到FF4。我们称这些路径为*关键路径*。

练习6：带多个时钟的简单路径
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*目标：练习带多个时钟的路径的时序分析。*

.. figure:: png/circ06.png

   练习6电路。

*任务：对于FF1到FF2的时序路径，执行以下操作：*

- *识别保持和建立的发射和捕获时钟时序。*
- *计算建立和保持余量。*

当起点和终点由不同源时钟驱动时，我们需要确定最坏情况（即最小）的发射和捕获沿配置。我们通过将时钟波形展开到它们的最小公倍数来做到这一点；在我们的情况下，公共周期是30纳秒（见下图）。

.. figure:: png/circ06_expanded_clocks_waveform.png

   将时钟展开到其周期的最小公倍数的波形。

在识别最坏情况条件后，我们获得以下余量：

    # 建立余量计算                               # 保持余量计算
    点               增量   总计                          点               增量   总计
    clka（上升）         0       20   <-- 发射时间 -->    clka（上升）         0       10
    FF1/CK              3       23                          FF1/CK              3       13
    G1/A                2       25                          G2/A                2       15
    FF2/D               0       25                          FF2/D               0       15
    数据到达                 25                          数据到达                 15

    clkb（上升）         0       22.5 <-- 捕获时间 -->   clkb（上升）         0        7.5
    FF2/CK              0       22.5                        FF2/CK              0        7.5
    FF2建立          -0.7     21.8                        FF2保持            0.3      7.8
    数据要求               21.8                        数据要求                7.8

    余量（要求 - 到达）    -3.2 < 0                   余量（要求 - 到达）   -7.2 < 0
    => 建立检查失败                                   => 保持检查通过

显然，多时钟练习是关于展开时钟波形的。下面还有两个时钟周期为10纳秒和30纳秒且具有不同相位对齐的示例。

.. figure:: png/circ06_variant_waveforms.png

   练习6电路的其他时序变化示例。

练习7：带上升/下降延迟的简单路径
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*目标：练习使用更复杂时序模型（如不同上升/下降延迟）的时序分析。*

.. figure:: png/circ07.png

   练习7电路。

*任务：对于FF1到FF2的时序路径，执行以下操作：*

- *计算数据路径和时钟路径的上升/下降延迟。*
- *计算建立和保持余量。*
- *如果FF2是负沿触发的，结果会如何变化？*

所有前面的练习都使用具有恒定单元弧的简单时序模型。现在我们考虑一个上升和下降单元弧产生不同延迟的模型。这一改变迫使时序分析计算并考虑上升和下降信号传播的有效组合。

上升/下降时序弧与单元输出的上升/下降相关！下表然后总结了各个路径/段的传播延迟。计算段``FF1/CK``到``FF2/D``的示例如下图所示。

========== ========== ============ ==================
起点       终点       变化         路径延迟 [纳秒]
========== ========== ============ ==================
FF1/CK     FF2/D      上升 (FF1/Q) 8
FF1/CK     FF2/D      下降 (FF1/Q) 7
clk        FF1/CK     上升 (clk)   3
clk        FF1/CK     下降 (clk)   4
clk        FF2/CK     上升 (clk)   3
clk        FF2/CK     下降 (clk)   4
========== ========== ============ ==================

.. figure:: png/circ07_data_path_delay.png

   计算``FF1/Q``上升/下降通过数据路径的传播。

对于建立余量，我们需要考虑*晚*数据路径和*早*时钟路径；反之亦然对于保持余量。在``FF1/CK``到``FF2/D``上，晚/早发生在``FF1/Q``上升/下降。在时钟路径上，不要被愚弄；只有``clk``上升会触发发射和捕获！余量计算如下（注意我们在列表中使用单元弧末端，因为它与电路图中的值更好地相关）：

    # 建立余量计算                               # 保持余量计算
    点               增量   总计                          点               增量   总计
    clk (r)             0        0                          clk (r)             0        0
    B1/Y (r)            1        1                          B1/Y (r)            1        1
    B2/Y (r)            2        3   <-- 发射时间 -->    B2/Y (r)            2        3
    FF1/Q (r)           2        5                          FF1/Q (f)           3        6
    G1/Y (f)            3        8                          G1/Y (r)            2        8
    G2/Y (r)            3       11                          G2/Y (f)            2       10
    FF2/D (r)           0       11                          FF2/D (f)           0       10
    数据到达                 11                          数据到达                 10
    
    clk (r)             0        7                          clk (r)             0        0
    B1/Y (r)            1        8                          B1/Y (r)            1        1
    B3/Y (r)            2       10   <-- 捕获时间 -->   B3/Y (r)            2        3
    FF2/CK (r)          0       10                          FF2/CK (r)          0        3
    FF2建立          -0.7      9.3                        FF2保持            0.3      3.3
    数据要求                9.3                        数据要求                3.3
    
    余量（要求 - 到达）   -1.7 < 0（！！！）              余量（要求 - 到达）   -6.7 < 0
    => 建立检查失败                                   => 保持检查通过

如果FF2是负沿触发的，那么我们需要考虑``clk``下降传播延迟到``FF2/CK``，并且还需要考虑改变的发射/捕获沿时序：

    # 建立余量计算                               # 保持余量计算
    点               增量   总计                          点               增量   总计
    clk (r)             0        0                          clk (r)             0        7
    ...                                                     ...
    数据到达                 11                          数据到达                 17
    
    clk (f)             0        3.5                        clk (f)             0        3.5
    B1/Y (f)            1        4.5                        B1/Y (f)            1        4.5
    B3/Y (f)            3        7.5 <-- 捕获时间 -->   B3/Y (f)            3        7.5
    FF2/CK (f)          0        7.5                        FF2/CK (f)          0        7.5
    FF2建立          -0.7      6.8                        FF2保持            0.3      7.8
    数据要求                6.8                        数据要求                7.8
    
    余量（要求 - 到达）   -4.2 < 0（！！！）              余量（要求 - 到达）   -9.2 < 0
    => 建立检查失败                                   => 保持检查通过

技术库
......

技术库是向EDA工具提供关于设计中可能使用的标准单元（和其他单元类型或IP）信息的文件。这些库有许多格式，有些是专有的，有些是标准化的，针对每个EDA功能量身定制。

STA工具通常需要以下基本信息：

- 单元列表及其逻辑功能
- 单元表征数据（时序、电容，可选功耗）

Liberty格式
~~~~~~~~~~~~

行业标准，*（Synopsys）Liberty*（``*.lib``），是大多数工具使用的格式，由技术供应商提供[#]_。Liberty语法是固定的但开放的；也就是说，它是一个属性和组/集合的层次结构，其中组包含较低级别的属性和组。

.. TBD consider adding reference to Liberty User Guide

Liberty语法如下所示：

        complex_attribute ( my_complex_attr_value );
        
        some_group (my_group_b) {
            /* 低级别属性 */
            /* 低级别组 */
        }
        
        ...
    }

大多数核心属性和组都是标准化的，典型的Liberty看起来如下：

::

    library(my_lib) {
        /* 库属性 */
        technology (cmos);
        delay_model: table_lookup;

        ... /* 其他库级属性 */

        /* 单元定义 */
        cell(my_cell_a) {
            ...
        }

        ... /* 其他单元定义 */
    }

.. [#] Liberty格式由Synopsys开发，现在与其合作伙伴协作进行未来发展。因此，格式的开放语义效果很好，但有时会成为不兼容性的来源。也就是说，不同的EDA供应商定义自己的属性或集合，其他EDA供应商可能不支持。

库属性
~~~~~~

常见的库级属性包括：

- 通用库类型属性（例如``technology``、``delay_model``）。
- 单位属性：定义与数字文字相关联的单位。相同的单位然后应用于SDC约束。

  ::
  
      /* 单位属性 */
      time_unit: "1ns";
      voltage_unit: "1V";
      ...
- 阈值属性：标识库表征的波形交叉点。它用于在混合具有不同阈值的单元时重新计算表征值。

  ::
  
      /* 阈值 */
      slew_upper_threshold_pct_rise: 80;
      slew_lower_threshold_pct_rise: 20;
      ...
      input_threshold_pct_rise: 50;
      input_threshold_pct_fall: 50;
      ...

- 工艺属性：定义库表征的工作条件。

  ::
  
      nom_process: 1.0;
      nom_voltage: 1.5;
      nom_temperature: 25.0;
      operating_conditions (tc_1p5v_25c) {
          process: 1;
          voltage: 1.5;
          temperature: 25;
      }
      default_operating_conditions : tc_1p5v_25c;

- 默认值：定义默认标称表征值，当未为单元、引脚或其他组明确定义时适用。
  
  ::
  
      default_input_pin_cap: 1.0;
      default_output_pin_cap: 1.0;
      ...

库供应商有时会定义用于自动化目的的有用属性。以下示例显示如何定义和使用用户定义的单元描述：

::

    /* 声明用户属性 */
    define(CELL_DESCR,cell,string);

    /* 使用该属性 */
    cell(AND2x1) {
        CELL_DESCR: "2输入与门，x1驱动强度。";
        ...
    }

库单元和时序
~~~~~~~~~~~~

Liberty库的核心是单元描述、它们的引脚、功能和时序。``cell``组捆绑了单元级属性（例如``area``、``leakage``、``dont_use``、``dont_touch``等）及其引脚的``pin``组。``pin``组定义引脚属性（例如``direction``、输入``capacitance``、输出``max_capacitance``、逻辑``function``）以及时序和其他表征数据（例如功耗或电流）的组。时序单元还包含标识时序功能（例如``ff``）及其属性（例如``clocked_on``）的组。

以下代码片段显示了组合单元和时序单元的一些特征：

::

    /* 组合单元 */
    cell(bufx1) {
        area: 1.2;
        pin(A) {
            direction: input;
            capacitance: 0.001;
        }
        pin(Y) {
            direction: output;
            max_capacitance: 0.05;
            function: "A";
            timing () {
                related_pin        : "A" ;
                timing_type        : combinational ;
                timing_sense       : positive_unate ;
                cell_fall(scalar) { values("2.0"); }
                cell_rise(scalar) { values("2.0"); }
                fall_transition(scalar) { values("0.3"); }
                rise_transition(scalar) { values("0.3"); }
            }
        }
    }

    /* 时序单元 */
    cell(dffrx1) {
        ...
        ff (Qint,QintB) {
            next_state: "D";
            clocked_on: "CK";
            clear: "!RB";
        }
        pin(CK)  {
            direction: input;
            capacitance: 0.001;
            clock: true;
            timing() {
                related_pin: "CK";
                timing_type: min_pulse_width;                /* 指定最小脉冲宽度检查 */
                rise_constraint(scalar) { values("1.0"); }
                fall_constraint(scalar) { values("1.0"); }
            }
        }
        pin(D) {
            ...
            timing() {
                related_pin: "CK";
                when: "RB";
                sdf_cond: "RB == 1'b1";
                timing_type: hold_rising;                   /* 指定CK上升沿的保持检查 */
                rise_constraint(scalar) { values("0.3"); }
                fall_constraint(scalar) { values("0.3"); }
            }
            timing() {
                ...
                timing_type: setup_rising;                  /* 指定CK上升沿的建立检查 */
                ...
            }
        }
        pin(Q) {
            ...
            function: "Qint";                               /* 使用状态元件内部定义的输出 */
            timing() {
                related_pin: "CK";
                timing_sense: non_unate;
                timing_type: rising_edge;
                cell_rise(scalar) { values("3.0"); }        /* CK上升沿的传播延迟 */
                cell_fall(scalar) { values("3.0"); }
                rise_transition(scalar) { values("0.3"); }  /* 输出转换 */
                fall_transition(scalar) { values("0.3"); }
            }
            timing() {
                related_pin: "RB";
                timing_sense: positive_unate;
                timing_type: clear;
                cell_fall(scalar) { values("1.0"); }        /* RB下降沿的传播延迟 */
                fall_transition(scalar) { values("0.2"); }  /* 输出转换 */
            }
        }
        ...
    }

时序表
~~~~~~

上面的单元示例使用了单一标量时序值，与我们`示例`_中使用的非常相似。在实践中，单元延迟随输入信号*转换速率*变化，当是传播延迟时，还取决于总输出负载（即电容）。表征过程在定义的范围内（对给定技术典型）扫描这些参数，并创建表征值的二维表。然后这些表用于基于电路中实际转换速率和负载值进行插值或外推。查看5x5表的单元传播延迟示例：

::

    library(my_lib) {
        ...
        lut_table_template(delay_template_5x5) {
            variable_1 : input_net_transition;
            variable_2 : total_output_net_capacitance;
            index_1 ("1000.0, 1002.0, 1003.0, 1004.0, 1006.0");
            index_2 ("1000.0, 1002.0, 1003.0, 1004.0, 1006.0");
        }
        ...
        cell(my_cell) {
            ...
            pin(Y)  {
                ...
                function : "(!A)";
                timing() {
                    related_pin : "A";
                    timing_sense : negative_unate;
                    cell_rise(delay_template_5x5) {
                        index_1 ("0.008, 0.08, 0.12, 0.16, 0.30");
                        index_2 ("0.01, 0.05, 0.08, 0.12, 0.24");
                        values ( \
                            "0.082, 0.369, 0.585, 0.872, 1.90", \
                            "0.108, 0.394, 0.610, 0.897, 1.93", \
                            "0.123, 0.408, 0.624, 0.912, 1.94", \
                            "0.137, 0.424, 0.637, 0.925, 1.96", \
                            "0.182, 0.468, 0.683, 0.967, 2.01");
                    }
                    cell_fall(delay_template_5x5) {
                        ...
                    }
                    ...
                }
            } /* Y */
            ...
        } /* my_cell */
        ...
    }   

库角
~~~~

除了取决于转换速率和负载外，单元延迟随工艺、电压和温度（即*PVT*）变化。我们将在后面（`PVT变化`_）讨论这种依赖关系。这里的关键点是每个单元库需要表征不同的PVT组合，并作为一组``*.lib``文件交付。PVT组合的选择来自库单元的典型工作条件（例如标称电压加/减10%，-40°C到125°C的工业温度范围）和工艺变化（即通常最慢/最差和最快/最好的晶体管）。

IP时序库
~~~~~~~~

我们在标准单元的背景下讨论了Liberty和时序。完整的芯片设计通常包括其他单元类型，通常称为IP，如IO单元、存储器和特殊硬宏（例如PLL、高速物理接口等）。

这些IP需要与标准单元具有相同的技术库，因此也需要具有Liberty格式的时序。在这方面，每个IP只是另一个``cell``，具有其特征属性、引脚和时序组。时序（如果定义）的定义方式与它是时序或组合单元时非常相似，取更合适者。

因此，从时序角度来看，STA分析最终将任何IP视为具有标准时序*约束*（例如建立/保持）的单元或将其传播延迟添加到*信号路径*。

PrimeTime实践操作
.................

本节是关于在STA工具的帮助下练习STA分析。我们将使用Synopsys PrimeTime（PT），但原理适用于其他STA工具，对ASIC和FPGA没有区别。本实践将教你定义基本用户约束（例如识别时钟及其周期时间）和如何报告STA结果（即控制要分析的时序检查）。

你将通过我们在`示例`_章节中进行的相同系列练习。

STA会话
~~~~~~~

典型的STA会话执行以下操作：

1. 加载技术库。
2. 加载设计。
3. 定义用户时序约束。
4. 分析设计。
5. 报告分析结果。

步骤3到5将在练习中实践。PrimeTime中的步骤1和2如下所示：

    # 设置技术库路径（步骤1的一部分）。注意使用
    # 编译后的Liberty格式*.db（而不是纯文本*.lib）。
    set link_path path/to/my_lib.db
    
    # 加载设计（步骤2的一部分）。
    read_verilog path/to/my_circuit.v
    
    # 链接库和设计（步骤1和2的完成）。
    link
    
    ... # 其他步骤

.. note:: 在`技术库`_章节中，我们介绍了``*.lib`` Liberty文件的语法。这些是纯文本文件，随着单元数量和表征参数的增加，文件可能变得非常大。因此，一些工具使用从``*.lib``转换的专有二进制格式。例如，PrimeTime使用通过Synopsys LibraryCompiler工具编译的``*.db``文件。

.. note:: 生产力提示：启动PrimeTime并获取许可证需要一些时间。与其离开会话并重新启动工具，你可以通过卸载设计和库，然后加载新的来重置配置：
   
       # 卸载设计
       remove_design [current_design]
       
       # 卸载库，其中<libname>是库名称，通常是
       # 库文件的基本名称
       remove_library <libname>

PT练习1：简单的触发器到触发器路径
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*目标：展示在没有时钟定义时*``report_timing``*没有什么可报告的。学习如何定义时钟和报告分析结果。*

*任务：*

- *使用*``circ01.v``*和*``sample_lib1.db``*设置PT会话。*
- *使用*``report_timing``*查看没有任何用户约束时的结果。*
- *使用*``create_clock``*定义时钟和时钟周期约束。*
- *报告建立和保持时序检查的结果。与*`练习1：简单的触发器到触发器路径`*中计算的结果进行比较。*

练习可以这样进行：

1. 更改到工作文件夹并启动PT：

       cd ...
       pt_shell

2. 设置分析STA会话：

   .. code-block:: text

       pt_shell> set link_path sample_lib1.db
       pt_shell> read_verilog circ01.v
       pt_shell> link
       Loading verilog file '.../circ01.v'
       Loading db file '.../sample_lib1.db'
       Linking design circ01...
       Information: 7 (77.78%) library cells are unused in library sample_lib1..... (LNK-045)
       Information: total 7 library cells are unused (LNK-046)
       Design 'circ01' was successfully linked.
       Information: There are 7 leaf cells, ports, hiers and 5 nets in the design (LNK-047)


.. note:: 编译后的``*.db``文件需要通过Synopsys ``lc_shell``（LibraryCompiler）创建。但是，如果你尝试直接使用``*.lib``文件，PrimeTime将尝试直接调用LibraryCompiler并自己获取编译后的库。以下是输出示例：

   .. code-block:: text

       pt_shell> set link_path sample_lib1.lib
       pt_shell> read_verilog circ01.v
       pt_shell> link
       Beginning read_lib...
       Using exec: /library_compiler/N-2017.12/linux64/lc/bin/lc_shell_exec
       Reading '.../sample_lib1.lib' ...
       Technology library 'sample_lib1' read successfully
       Loading verilog file '.../circ01.v'
       Loading db file '.../sample_lib1.lib'
       Loading db file '/tmp/_pt1r2wdkga/1.db'
       Linking design circ01...
       Design 'circ01' was successfully linked.
       Information: ...

3. 尝试报告STA结果。你将看到没有任何报告，因为我们还没有设置任何约束：

   .. code-block:: text

       pt_shell> report_timing
       ****************************************
       Report : timing
               -path_type full
               -delay_type max
               -max_paths 1
               -sort_by slack
       Design : circ01
       Version: O-2018.06-SP4
       Date   : Mon Jul 29 18:49:07 2019
       ****************************************

       No constrained paths.

4. 定义具有一定周期的时钟：

   .. code-block:: text

       # 使用时定义时钟：
       #   create_clock -name <ID> -period <cycle-time> <clock_port>
       #
       # <ID>可以是您选择的任何名称，但最好不要与其他对象名称冲突，
       # 例如主端口、设计和模块或单元的实例。
       # <cycle-time>是指定为浮点数的时钟周期（单位
       # 由库定义）。
       #
       # 如果没有其他选项，命令将定义具有以下波形的时钟，
       # 其中`T`是使用的<cycle-time>。
       #     ________________
       #    |                |________________|
       #    0               T/2               T

       pt_shell> create_clock -name CLK -period 20 clk

5. 报告建立检查分析的结果：

   .. code-block:: text

       # 当不带其他选项调用`report_timing`时，它打印具有最差余量的
       # 建立检查的结果。
       pt_shell> report_timing
       ****************************************
       Report : timing
        -path_type full
        -delay_type max
        -max_paths 1
        -sort_by slack
       Design : circ01
       Version: O-2018.06-SP4
       Date   : Sun Jun 23 08:40:57 2019
       ****************************************

         Startpoint: FF1 (rising edge-triggered flip-flop clocked by CLK)
         Endpoint: FF2 (rising edge-triggered flip-flop clocked by CLK)
         Path Group: CLK
         Path Type: max

         Point                                    Incr       Path
         ---------------------------------------------------------------
         clock CLK (rise edge)                   0.000      0.000
         clock network delay (ideal)             0.000      0.000
         FF1/CK (dffrx1)                         0.000      0.000 r
         FF1/Q (dffrx1)                          3.000      3.000 f
         G1/Y (invx1)                            2.000      5.000 r
         FF2/D (dffrx1)                          0.000      5.000 r
         data arrival time                                  5.000

         clock CLK (rise edge)                  20.000     20.000
         clock network delay (ideal)             0.000     20.000
         clock reconvergence pessimism           0.000     20.000
         FF2/CK (dffrx1)                                   20.000 r
         library setup time                     -0.700     19.300
         data required time                                19.300
         ---------------------------------------------------------------
         data required time                                19.300
         data arrival time                                 -5.000
         ---------------------------------------------------------------
         slack (MET)                                       14.300

6. 要报告保持检查结果，您必须使用``-delay_type min``：

   .. code-block:: text

       # 报告保持时序。
       pt_shell> report_timing -path_type full_clock_expanded -delay_type min
       ****************************************
       Report : timing
        -path_type full
        -delay_type min
        -max_paths 1
        -sort_by slack
       Design : circ01
       Version: O-2018.06-SP4
       Date   : Sun Jun 23 08:40:46 2019
       ****************************************

         Startpoint: FF1 (rising edge-triggered flip-flop clocked by CLK)
         Endpoint: FF2 (rising edge-triggered flip-flop clocked by CLK)
         Path Group: CLK
         Path Type: min

         Point                                    Incr       Path
         ---------------------------------------------------------------
         clock CLK (rise edge)                   0.000      0.000
         clock network delay (ideal)             0.000      0.000
         FF1/CK (dffrx1)                         0.000      0.000 r
         FF1/Q (dffrx1)                          3.000      3.000 f
         G1/Y (invx1)                            2.000      5.000 r
         FF2/D (dffrx1)                          0.000      5.000 r
         data arrival time                                  5.000

         clock CLK (rise edge)                   0.000      0.000
         clock network delay (ideal)             0.000      0.000
         clock reconvergence pessimism           0.000      0.000
         FF2/CK (dffrx1)                                    0.000 r
         library hold time                       0.300      0.300
         data required time                                 0.300
         ---------------------------------------------------------------
         data required time                                 0.300
         data arrival time                                 -5.000
         ---------------------------------------------------------------
         slack (MET)                                        4.700

7. 建立余量14.3纳秒和保持余量4.7纳秒（注意PT报告自动取反结果以使通过的检查具有正余量）对应于`练习1：简单的触发器到触发器路径`。

PT练习2：负沿时钟触发的影响
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*目标：展示具有不同边沿触发器的电路的时序报告。*

*任务：*

- *使用*``circ02.v``*和*``sample_lib1.db``*设置PT会话。*
- *定义时钟和时钟周期约束。*
- *报告建立和保持时序检查的结果。与*`练习2：负沿时钟触发的影响`*中计算的结果进行比较。*

与前面的PT练习没有什么新内容。工具报告应如下所示（分别产生建立和保持余量4.3和14.7）：

   .. code-block:: text

    ****************************************                                 ****************************************
    Report : timing                                                          Report : timing
    	-path_type full                                                       	-path_type full
    	-delay_type max                                                       	-delay_type max
    	-max_paths 1                                                          	-max_paths 1
    	-sort_by slack                                                        	-sort_by slack
    Design : circ02                                                          Design : circ02
    Version: O-2018.06-SP4                                                   Version: O-2018.06-SP4
    Date   : Mon Jul 29 19:17:39 2019                                        Date   : Mon Jul 29 19:17:48 2019
    ****************************************                                 ****************************************
      Startpoint: FF1 (rising edge-triggered flip-flop clocked by CLK)         Startpoint: FF1 (rising edge-triggered flip-flop clocked by CLK)
      Endpoint: FF2 (falling edge-triggered flip-flop clocked by CLK)          Endpoint: FF2 (falling edge-triggered flip-flop clocked by CLK)
      Path Group: CLK                                                          Path Group: CLK
      Path Type: max                                                           Path Type: min

      Point                                    Incr       Path                 Point                                    Incr       Path
      ---------------------------------------------------------------          ---------------------------------------------------------------
      clock CLK (rise edge)                    0.00       0.00                 clock CLK (rise edge)                   20.00      20.00
      clock network delay (ideal)              0.00       0.00                 clock network delay (ideal)              0.00      20.00
      FF1/CK (dffrx1)                          0.00       0.00 r               FF1/CK (dffrx1)                          0.00      20.00 r
      FF1/Q (dffrx1)                           3.00       3.00 f               FF1/Q (dffrx1)                           3.00      23.00 f
      G1/Y (invx1)                             2.00       5.00 r               G1/Y (invx1)                             2.00      25.00 r
      FF2/D (dffnrx1)                          0.00       5.00 r               FF2/D (dffnrx1)                          0.00      25.00 r
      data arrival time                                   5.00                 data arrival time                                  25.00

      clock CLK (fall edge)                   10.00      10.00                 clock CLK (fall edge)                   10.00      10.00
      clock network delay (ideal)              0.00      10.00                 clock network delay (ideal)              0.00      10.00
      clock reconvergence pessimism            0.00      10.00                 clock reconvergence pessimism            0.00      10.00
      FF2/CKN (dffnrx1)                                  10.00 f               FF2/CKN (dffnrx1)                                  10.00 f
      library setup time                      -0.70       9.30                 library hold time                        0.30      10.30
      data required time                                  9.30                 data required time                                 10.30
      ---------------------------------------------------------------          ---------------------------------------------------------------
      data required time                                  9.30                 data required time                                 10.30
      data arrival time                                  -5.00                 data arrival time                                 -25.00
      ---------------------------------------------------------------          ---------------------------------------------------------------
      slack (MET)                                         4.30                 slack (MET)                                        14.70



PT练习3：带时钟树的简单触发器到触发器路径
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*目标：展示带有时钟树的电路的时序报告。*

*任务：*

- *使用*``circ03.v``*和*``sample_lib1.db``*设置PT会话。*
- *定义时钟和时钟周期约束。*
- *报告建立和保持时序检查的结果。与*`练习3：带时钟树的简单触发器到触发器路径`*中计算的结果进行比较。*

分析程序与前面的示例相同。但是，我们确实扩展了``report_timing``选项以获得完整的时钟路径列表。

::

       # 除非另有指定，时序报告将时钟路径压缩为单个
       # 值。使用`-path_type full_clock_expanded`获取完整路径列表。
       pt_shell> report_timing -path_type full_clock_expanded

完整的建立/保持列表如下所示：

   .. code-block:: text

    ****************************************                               ****************************************
    Report : timing                                                        Report : timing
    	-path_type full_clock_expanded                                       	-path_type full_clock_expanded
    	-delay_type max                                                      	-delay_type min
    	-max_paths 1                                                         	-max_paths 1
    	-sort_by slack                                                       	-sort_by slack
    Design : circ03                                                        Design : circ03
    Version: O-2018.06-SP4                                                 Version: O-2018.06-SP4
    Date   : Mon Jul 29 19:16:43 2019                                      Date   : Mon Jul 29 19:16:53 2019
    ****************************************                               ****************************************
      Startpoint: FF1 (rising edge-triggered flip-flop clocked by CLK)       Startpoint: FF1 (rising edge-triggered flip-flop clocked by CLK)
      Endpoint: FF2 (rising edge-triggered flip-flop clocked by CLK)         Endpoint: FF2 (rising edge-triggered flip-flop clocked by CLK)
      Last common pin: clk                                                   Last common pin: clk
      Path Group: CLK                                                        Path Group: CLK
      Path Type: max                                                         Path Type: min

      Point                                    Incr       Path               Point                                    Incr       Path
      ---------------------------------------------------------------        ---------------------------------------------------------------
      clock CLK (rise edge)                    0.00       0.00               clock CLK (rise edge)                    0.00       0.00
      clock source latency                     0.00       0.00               clock source latency                     0.00       0.00
      clk (in)                                 0.00       0.00 r             clk (in)                                 0.00       0.00 r
      B1/Y (bufx4)                             1.00       1.00 r             B1/Y (bufx4)                             1.00       1.00 r
      B2/Y (bufx1)                             2.00       3.00 r             B2/Y (bufx1)                             2.00       3.00 r
      FF1/CK (dffrx1)                          0.00       3.00 r             FF1/CK (dffrx1)                          0.00       3.00 r
      FF1/Q (dffrx1)                           3.00       6.00 r             FF1/Q (dffrx1)                           3.00       6.00 r
      G1/Y (nand2x1)                           2.00       8.00 f             G1/Y (nand2x1)                           2.00       8.00 f
      G2/Y (invx1)                             2.00      10.00 r             G2/Y (invx1)                             2.00      10.00 r
      FF2/D (dffrx1)                           0.00      10.00 r             FF2/D (dffrx1)                           0.00      10.00 r
      data arrival time                                  10.00               data arrival time                                  10.00

      clock CLK (rise edge)                    7.00       7.00               clock CLK (rise edge)                    0.00       0.00
      clock source latency                     0.00       7.00               clock source latency                     0.00       0.00
      clk (in)                                 0.00       7.00 r             clk (in)                                 0.00       0.00 r
      B1/Y (bufx4)                             1.00       8.00 r             B1/Y (bufx4)                             1.00       1.00 r
      B3/Y (bufx1)                             2.00      10.00 r             B3/Y (bufx1)                             2.00       3.00 r
      FF2/CK (dffrx1)                          0.00      10.00 r             FF2/CK (dffrx1)                          0.00       3.00 r
      clock reconvergence pessimism            0.00      10.00               clock reconvergence pessimism            0.00       3.00
      library setup time                      -0.70       9.30               library hold time                        0.30       3.30
      data required time                                  9.30               data required time                                  3.30
      ---------------------------------------------------------------        ---------------------------------------------------------------
      data required time                                  9.30               data required time                                  3.30
      data arrival time                                 -10.00               data arrival time                                 -10.00
      ---------------------------------------------------------------        ---------------------------------------------------------------
      slack (VIOLATED)                                   -0.70               slack (MET)                                         6.70




PT练习4：并行触发器到触发器路径
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*目标：练习使用*``-from``、``-through``*和*``-to``*选项的时序报告。*

*任务：*

- *使用*``circ04.v``*和*``sample_lib1.db``*设置PT会话。*
- *定义时钟和时钟周期约束。*
- *报告以下路径的时序分析结果：*

  - *from FF1*
  - *from FF1/CK to FF2/D*
  - *to FF2/Q*
  - *through G2*

同样，标准的建立和保持分析程序应该没有什么令人惊讶的；结果将与`练习4：并行触发器到触发器路径`_中的结果相同。

FF1和FF2之间存在并行路径，让你可以看到更精确地指定时序路径的效果。要练习的命令如下：

1. 仅指定起点将产生与省略它相同的结果。原因是电路中只有一个时序路径，因此没有其他可报告的。

   ::

       # 通过起点指定路径
       pt_shell> report_timing -from FF1
       ...

2. 同时指定起点和终点。这次我们将点指定到实例引脚。同样，你将获得与之前相同的报告，因为我们识别了设计中的唯一路径。

   ::

       # 通过起点和终点指定路径
       pt_shell> report_timing -from FF1/CK -to FF2/D
       ...

3. 仅指定终点将再次产生设计中唯一的时序路径，前提是该终点被正确指定。注意作业要求使用``FF2/Q``作为终点，但触发器输出不能是时序路径的终点。所以你应该看到STA工具抱怨：

   ::

       # 指定错误的终点
       pt_shell> report_timing -to FF2/Q
       ****************************************
       Report : timing
       	-path_type full
       	-delay_type max
       	-max_paths 1
       	-sort_by slack
       Design : circ04
       Version: O-2018.06-SP4
       Date   : Sat Aug 24 18:26:49 2019
       ****************************************

       Warning: There is 1 invalid end point for constrained paths. (UITE-416)
       No constrained paths.

4. 使用``-through``点可以让你选择除最坏情况之外的分析信号路径。在`练习4：并行触发器到触发器路径`_中我们确定，通过G1的路径产生最差的建立时序。因此将*经过*点更改为G2将报告更大的余量。

   ::

       # 通过特定门指定路径
       pt_shell> report_timing -through G2
       ****************************************
       Report : timing
       	-path_type full
       	-delay_type max
       	-max_paths 1
       	-sort_by slack
       Design : circ04
       Version: O-2018.06-SP4
       Date   : Sat Aug 24 18:27:12 2019
       ****************************************
         Startpoint: FF1 (rising edge-triggered flip-flop clocked by CLK)
         Endpoint: FF2 (rising edge-triggered flip-flop clocked by CLK)
         Last common pin: clk
         Path Group: CLK
         Path Type: max
       
         Point                                    Incr       Path
         ---------------------------------------------------------------
         clock CLK (rise edge)                    0.00       0.00
         clock network delay (propagated)         0.00       0.00
         FF1/CK (dffrx1)                          0.00       0.00 r
         FF1/Q (dffrx1)                           3.00       3.00 r
         G2/A (invx4) <-                          0.00       3.00 r
         G2/Y (invx4) <-                          1.00       4.00 f
         G3/Y (nand2x1)                           2.00       6.00 r
         FF2/D (dffrx1)                           0.00       6.00 r
         data arrival time                                   6.00
       
         clock CLK (rise edge)                    2.00       2.00
         clock network delay (propagated)         6.00       8.00
         clock reconvergence pessimism            0.00       8.00
         FF2/CK (dffrx1)                                     8.00 r
         library setup time                      -0.70       7.30
         data required time                                  7.30
         ---------------------------------------------------------------
         data required time                                  7.30
         data arrival time                                  -6.00
         ---------------------------------------------------------------
         slack (MET)                                         1.30


PT练习5：小型电路分析
~~~~~~~~~~~~~~~~~~~~~~

*目标：练习更复杂电路的时序分析。*

*任务：*

- *除非提供了网表，否则根据*`练习5：小型电路分析`*中的电路创建一个。*
- *使用*``sample_lib1.db``*设置PT会话。*
- *定义时钟和时钟周期约束。*
- *识别具有最差建立和保持余量的路径。*
- *识别所有时序路径的最差余量。*

第一部分很简单。具有最差建立和保持余量的路径分别由默认的``report_timing -delay_type max``和``report_timing -delay_type min``报告。

要报告其他路径，我们需要使用其他``report_timing``选项。特别有趣的是这两个：

- ``-nworst N``：报告每个终点最多N条最坏路径。也就是说，如果存在更多并行路径，如`练习4：并行触发器到触发器路径`_中，使用``-nworst``将报告这些路径。但是，如果你在练习4上尝试，你需要使用N为3或更大。原因是，在这种情况下，最坏路径涵盖信号上升和下降转换，因此第二条路径在第三位报告。

  此设置默认为1。

- ``-maxpaths M``：报告最多M条路径。由于路径通常按余量排序，这将报告M条最坏路径。

  此设置默认为1。

  ``maxpath``有一个陷阱。除非被覆盖，否则它将``-slack_lesser_than``设置为0，意味着默认情况下只报告违规路径。在我们的示例中，因此你需要使用某个足够大的余量限制，例如``-slack_lesser_than 100``。

这两个选项``nworst``和``maxpaths``经常一起使用。在只关心到终点的多条路径之一的情况下，你将使用``-max_paths N -nworst 1``。尝试一下以收集我们示例中的最差余量。

我们还可以做一项改进。我们只关心余量，而不是路径的所有细节。我们可以使用``-path_type summary``选项获得不太详细的报告：

::

    pt_shell> report_timing -slack_lesser_than 100 -nworst 4 -max_paths 10 -path_type summary

    ****************************************              ****************************************
    Report : timing                                       Report : timing
    	-path_type summary                                 	-path_type summary
    	-delay_type max                                    	-delay_type min
    	-nworst 4                                          	-nworst 4
    	-slack_lesser_than 100.00                          	-slack_lesser_than 100.00
    	-max_paths 100                                     	-max_paths 100
    	-sort_by slack                                     	-sort_by slack
    Design : circ05                                       Design : circ05
    Version: O-2018.06-SP4                                Version: O-2018.06-SP4
    Date   : Sat Aug 24 18:43:29 2019                     Date   : Sat Aug 24 18:43:37 2019
    ****************************************              ****************************************

    Startpoint            Endpoint             Slack      Startpoint            Endpoint             Slack
    -------------------------------------------------     --------------------------------------------------
    FF2/CK (dffrx1)       FF3/D (dffrx1)       2.30       FF1/CK (dffrx1)       FF4/D (dffrx1)       1.70
    FF2/CK (dffrx1)       FF3/D (dffrx1)       2.30       FF1/CK (dffrx1)       FF4/D (dffrx1)       1.70
    FF2/CK (dffrx1)       FF3/D (dffrx1)       2.30       FF1/CK (dffrx1)       FF4/D (dffrx1)       1.70
    FF3/CK (dffrx1)       FF4/D (dffrx1)       6.30       FF3/CK (dffrx1)       FF4/D (dffrx1)       2.70
    FF3/CK (dffrx1)       FF4/D (dffrx1)       6.30       FF3/CK (dffrx1)       FF4/D (dffrx1)       2.70
    FF1/CK (dffrx1)       FF3/D (dffrx1)       6.30       FF1/CK (dffrx1)       FF3/D (dffrx1)       2.70
    FF1/CK (dffrx1)       FF3/D (dffrx1)       6.30       FF1/CK (dffrx1)       FF3/D (dffrx1)       2.70
    FF1/CK (dffrx1)       FF4/D (dffrx1)       7.30       FF2/CK (dffrx1)       FF3/D (dffrx1)       6.70
    FF1/CK (dffrx1)       FF4/D (dffrx1)       7.30       FF2/CK (dffrx1)       FF3/D (dffrx1)       6.70  


PT练习6：带多个时钟的简单路径
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*目标：展示更复杂的时钟定义。*

*任务：*

- *使用*``circ06.v``*和*``sample_lib1.db``*设置PT会话。*
- *定义时钟并报告建立和保持的余量。*

要完成练习，你需要使用适当的相移定义第二个时钟。为此，``create_clock``命令有``-waveform``选项。当你需要定义除1:1占空比之外的其他占空比时，你将使用相同的选项。

::

    # 定义相移时钟波形。`-waveform {...}`接受
    # 上升和下降沿时间列表。第一个数字始终是
    # 上升沿。
    pt_shell> create_clock -name CLKB -period 15 -waveform {7.5 15} clkb
    ...


PT练习7：带上升/下降延迟的简单路径
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*目标：练习转换相关时序的分析。*

*任务：*

- *使用**circ03.v**和**sample_lib2.db**设置PT会话。*
- *定义时钟并报告建立和保持的余量。*
- *报告对起点转换类型有控制的时序：*
  
  - ``report_timing -fall_from FF1/Q``
  - ``report_timing -rise_from FF1/Q``

以下报告对比了保持检查的下降和上升报告：

::

    ****************************************                               ****************************************
    Report : timing                                                        Report : timing
    	-path_type full_clock_expanded                                      	-path_type full_clock_expanded
    	-delay_type min                                                     	-delay_type min
    	-max_paths 1                                                        	-max_paths 1
    	-sort_by slack                                                      	-sort_by slack
    Design : circ03                                                        Design : circ03
    Version: O-2018.06-SP4                                                 Version: O-2018.06-SP4
    Date   : Sun Jun 23 12:05:40 2019                                      Date   : Sun Jun 23 12:06:39 2019
    ****************************************                               ****************************************
      Startpoint: FF1 (rising edge-triggered flip-flop clocked by CLK)       Startpoint: FF1 (rising edge-triggered flip-flop clocked by CLK)
      Endpoint: FF2 (rising edge-triggered flip-flop clocked by CLK)         Endpoint: FF2 (rising edge-triggered flip-flop clocked by CLK)
      Last common pin: clk                                                   Last common pin: clk
      Path Group: CLK                                                        Path Group: CLK
      Path Type: min                                                         Path Type: min
                                                                            
      Point                                    Incr       Path               Point                                    Incr       Path
      ---------------------------------------------------------------        ---------------------------------------------------------------
      clock CLK (rise edge)                   0.000      0.000               clock CLK (rise edge)                   0.000      0.000
      clock source latency                    0.000      0.000               clock source latency                    0.000      0.000
      clk (in)                                0.000      0.000 r             clk (in)                                0.000      0.000 r
      B1/Y (bufx4)                            1.000      1.000 r             B1/Y (bufx4)                            1.000      1.000 r
      B2/Y (bufx1)                            2.000      3.000 r             B2/Y (bufx1)                            2.000      3.000 r
      FF1/CK (dffrx1)                         0.000      3.000 r             FF1/CK (dffrx1)                         0.000      3.000 r
      FF1/Q (dffrx1)                          3.000      6.000 f  <--        FF1/Q (dffrx1) <-                       2.000      5.000 r  <--
      G1/Y (nand2x1)                          2.000      8.000 r             G1/Y (nand2x1)                          3.000      8.000 f
      G2/Y (invx1)                            2.000     10.000 f             G2/Y (invx1)                            3.000     11.000 r
      FF2/D (dffrx1)                          0.000     10.000 f             FF2/D (dffrx1)                          0.000     11.000 r
      data arrival time                                 10.000               data arrival time                                 11.000
                                                                            
      clock CLK (rise edge)                   0.000      0.000               clock CLK (rise edge)                   0.000      0.000
      clock source latency                    0.000      0.000               clock source latency                    0.000      0.000
      clk (in)                                0.000      0.000 r             clk (in)                                0.000      0.000 r
      B1/Y (bufx4)                            1.000      1.000 r             B1/Y (bufx4)                            1.000      1.000 r
      B3/Y (bufx1)                            2.000      3.000 r             B3/Y (bufx1)                            2.000      3.000 r
      FF2/CK (dffrx1)                         0.000      3.000 r             FF2/CK (dffrx1)                         0.000      3.000 r
      clock reconvergence pessimism           0.000      3.000               clock reconvergence pessimism           0.000      3.000
      library hold time                       0.300      3.300               library hold time                       0.300      3.300
      data required time                                 3.300               data required time                                 3.300
      ---------------------------------------------------------------        ---------------------------------------------------------------
      data required time                                 3.300               data required time                                 3.300
      data arrival time                                -10.000               data arrival time                                -11.000
      ---------------------------------------------------------------        ---------------------------------------------------------------
      slack (MET)                                        6.700               slack (MET)                                        7.700


STA中级主题
...........

电路外部环境
~~~~~~~~~~~~

*外部*是分析环境中位于被分析电路周围的部分。到目前为止，我们建模的外部唯一组件是通过``create_clock``的时钟发生器。通常还有更多我们需要建模的。

.. figure:: png/design_exterior.png

   被分析设计的通用外部。

时序例外
~~~~~~~~

假路径
^^^^^^^^

多周期路径
^^^^^^^^^^^^

最小/最大延迟路径
^^^^^^^^^^^^^^^^^^

PVT变化
~~~~~~~

更多术语
........

这里我们回顾`术语`_章节之外介绍的术语。

理想时钟
  时钟的分配网络是理想化的，被认为不会引起时钟传播延迟。因此，对于*理想时钟*，没有*时钟偏斜*。

时钟树
  时钟分配网络。通常由缓冲器和反相器组成，用于减少时钟段上的容性负载（从而避免最大电容违规）并用于平衡或分散时钟偏斜。
  
  理论上，在没有时钟偏斜的完全平衡时钟树中，我们将获得最佳时序结果。这在实践中几乎不可能，因此术语*平衡*意味着最小化时钟偏斜。
  
  在实践中，特别是对于大型电路，理想的"无偏斜"情况是不希望的，因为它会使所有触发器在同一时刻翻转，因此可能导致动态功耗的大幅峰值。因此，一些偏斜是受欢迎的，以分散突然的电流消耗。

时钟偏斜
  同一*时钟域*中触发器时钟输入处的时钟到达时间差异。在最一般的意义上，它指这种差异的最大值。
  
  术语*偏斜*也应用于数据路径，例如总线的各个位。

时钟域
  由同一时钟源触发/计时的时序元件集合。

关键路径
  具有最差/最小余量的时序路径。建立和保持检查（和其他检查）的关键路径可能不同。

无效路径
  其时序无法确定的路径。有不同的原因可以使路径无效，例如缺少时序约束、存在时序例外或常数传播。

PVT角
  *PVT*、*角*或*PVT角*是工作条件的术语。*PVT*是工艺（P）、电压（V）和温度（T）的三元组。时序库针对单一PVT条件进行表征。时序通常是每个参数的单调函数[#]_，因此要覆盖PVT参数范围内的最小/最大时序，我们实际上只需要考虑每个参数的最小/最大值。也就是说，PVT立方体的*角*。

.. [#] 一个值得注意的例外是温度，可能存在*温度反转*，当从最高温度下降时，延迟会减少到某一点，进一步降低温度会导致延迟再次上升。

STA高级主题
...........

本节提供对您在实践中很可能遇到的一些高级STA方面的参考。主题列表肯定不完整，每个设计/项目都会给经验丰富的STA工程师带来惊喜。

时钟域交叉（CDC）
~~~~~~~~~~~~~~~~~

CDC通常专注于RTL设计。不过，它确实需要在其他领域给予足够的关注，包括时序分析和布局布线。在单独的文章/要点`CDC时序约束 <https://gist.github.com/brabect1/7695ead3d79be47576890bbcd61fe426>`_中讨论了约束CDC路径的建议。

片上变化（OCV）和时序降额
~~~~~~~~~~~~~~~~~~~~~~~~~

时序库考虑了精确的工艺/电压/温度条件。类似地，SDC约束也可以这样做。然而，实际工作条件肯定与用于STA的条件不同（例如电压电平会波动，电压电平会在电源分配网络上下降并响应电流消耗峰值，制造工艺在晶圆厂中波动，参数在晶圆之间变化等）。

隐含的工作条件变化具有全局和局部成分。全局变化通过在对真实硅片运行位置的边界形成"框"的角条件下运行STA分析来抵消。类似地，用户通常将SDC约束表示为最小/最大对（例如输入/输出延迟和转换、输出负载）。尽管考虑了工作条件的最坏情况和最好情况偏移，每个芯片都会遭受局部变化（即*片上变化*或*OCV*），意味着有些门会稍微快一些，有些会稍微慢一些，有些会看到稍高的温度，或稍低的电压。

为了考虑局部变化，设计师增加额外的余量以确保芯片的性能保持在安全方面。这通常来自从门库缩放（或降额）时序以产生更悲观的时序。因此术语*时序降额*。

引入时序降额（也称为*时序降额*）的命令是``set_timing_derate``。以下示例设置+/-10%的降额，使得慢路径变慢10%，快路径变快10%。

::

    pt_shell> set_timing_derate -late  1.1
    pt_shell> set_timing_derate -early 0.9

更多详细信息请参阅单独的文章/要点`OCV和时序降额 <https://gist.github.com/brabect1/6281f4cf9fb53002fb17f15fa3bf4f62>`_。

高级OCV（AOCV）和统计OCV（SOCV）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

AOCV和SOCV是用于亚微米技术建模片上变化的更精细机制。一般的想法是，局部**工艺变化**（！）倾向于在整个芯片上平均。也就是说，假设所有门都慢10%或快10%是一个概率接近零的极端情况。因此，虽然一个门变慢/变快的机会是有意义的，但在10个门长的时序路径中所有门都变慢/变快的机会很小（并随着时序路径长度进一步减少）。

因此，通过``set_timing_derate``使用平坦OCV变得过于悲观，无法有意义地建模更精细技术节点（例如65纳米及以下）的工艺变化。

.. note:: 使用更先进节点的平坦余量会导致错误的时序违规或过度设计。两者都是次优的，因为数字设计方法中已经存在足够的保守性。

更多详细信息请参阅单独的文章/要点`OCV和时序降额 <https://gist.github.com/brabect1/6281f4cf9fb53002fb17f15fa3bf4f62>`_。

数据到数据检查
~~~~~~~~~~~~~~

STA的主要功能是检查时数据信号到时钟信号时序，例如建立和保持约束要求数据信号在有效时钟沿周围保持稳定。在某些情况下，我们需要将数据变化约束到时钟事件，而是另一个数据信号事件。这些被称为*数据到数据检查*。您可以在具有异步接口的硬宏中频繁找到它们；但也在具有异步置位和复位的触发器中，以强制执行一个优先于另一个。

STA提供了表达和验证此类依赖关系的机制。机制包括约束命令``set_data_check``和特定的库时序弧。示例请参阅文章/要点`STA数据到数据检查 <https://gist.github.com/brabect1/3b12ad2e90416fc9b6692ef3a242f23d>`_。

.. note:: 虽然STA通常提供数据到数据检查的机制，但大多数物理实现工具（即综合、布局布线）忽略它们。这非常不幸，因为用户无法使用SDC约束使实现工具检测和修复数据到数据时序违规。因此，使用数据到数据STA机制只能在物理实现完成后帮助检测时序问题。

占空比抖动
~~~~~~~~~~

许多芯片设计具有在某个范围内的时钟占空比规范，例如50% +/-10%。在单独的文章/要点`约束占空比抖动 <https://gist.github.com/brabect1/82505e8af2f9732bb6750678759af0b3>`_中讨论了建模此占空比变化的选项。

异步计数器
~~~~~~~~~~

这是一个真正的小众主题，因为真正的异步计数器在数字设计中零星出现。不过，有些情况下它们确实存在，它们的时序可能需要分析。在这种情况下，请参阅单独的文章/要点`异步计数器的STA约束 <https://gist.github.com/brabect1/d0463621efd2a8318695d8320ac17807>`_中的详细信息。

总结
----

本材料应该让您了解静态时序分析如何工作，以及**STA对电路的所有了解都来自约束**。

约束部分由技术库（``*.lib``文件，包含建立、保持、min_pulse_width和其他单元时序）定义，部分由用户（通过SDC命令如``create_clock``、``set_input_delay``、``set_output_delay``等）定义。

您作为数字设计师的工作是定义准确表示电路要运行环境的时序约束，并在默认STA检查过于保守或无法充分建模现实的地方放松时序。

参考文献
----------

.. [Golson2014] Golson, Steve. *同步和亚稳态。* Synopsys用户组（SNUG）硅谷2014。

.. lessons learned from [Golson2014]_
.. - 两个异步域边界上的亚稳态是肯定的
.. - 平均故障间隔时间（MTBF）是故障率的倒数
.. - 2FF同步器不是奇迹，有MTBF（故障意味着第2个FF进入亚稳态）
..   这是技术参数、FF设计、同步器设计和接收时钟周期的函数
.. - 设计师可以确定同步器的MTBF（然后是整个系统的MTBF），但他们很少这样做
..   （相反，他们使用2FF同步器作为确定性解决方案）
.. - 结论：
..   - 设计您的2FF同步器以最大化其MTBF（彼此靠近，最小化第1个FF的负载电容）
..   - 放松同步器时钟周期指数级改善MTBF

.. [Wakerly87] Wakerly, John. *同步器和亚稳态设计师指南，第一部分。* Microprocessor Report 1，第1期（1987）：4-8。

.. [ChaneyMolnar73] Chaney, Thomas J., Molnar, Charles E. *同步器和仲裁器电路的异常行为。* IEEE Transactions on Computers，100，第4期（1973）：421-422。
