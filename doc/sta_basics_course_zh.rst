.. Copyright (C) 2019 Tomas Brabec
.. 
.. 本文档采用知识共享署名4.0国际许可协议进行许可
.. (cc-by-4.0, http://creativecommons.org/licenses/by/4.0/).

静态时序分析基础
=============================

本作品采用 `知识共享署名4.0国际许可协议 <http://creativecommons.org/licenses/by/4.0/>`_ |cc_by_40_logo| 进行许可。

.. |cc_by_40_logo| image:: https://i.creativecommons.org/l/by/4.0/88x31.png
  :alt: CC BY 4.0

.. contents::

简介
-----

本节为如何从静态时序分析的角度理解数字电路奠定基础，有信心的读者可以直接跳转到 `静态时序分析`_ 部分。

数字电路
...............

数字电路可以通过以下两个方面来刻画，我们将进一步讨论：

- 对时钟敏感（包含同步性的前提）
- 从某些物理层面进行抽象（包括使用二进制逻辑）

平稳、（通常）固定已知频率时钟的存在是数字设计的基本前提。从已知的频率中，我们合成电路功能的粗粒度时序，并使用时钟事件在状态之间转换电路、响应输入和更新输出。这本质上将数字电路视为状态机，其中时序元件保存状态，组合元件定义状态相关的功能。

.. figure:: png/generic_digital_circuit.png

   数字电路的通用结构。

更高层次的抽象提高了大规模数字电路所需的工程师生产力。以下是抽象使用的几个例子：

- 二进制逻辑：用0、1以及偶尔的高阻态和未知态（X）进行思考简化了功能推理。在这里，我们从实际的电压电平、阈值以及从一个逻辑状态到另一个逻辑状态的变化从来都不是离散的这一事实中进行抽象。

- 同步性：当我们将时钟理想化时，我们假设数字电路是完全同步的（或在存在多个异步时钟时是多同步的）。同步性的前提让我们忽略许多真实世界中确实存在的物理层面（例如组合电路中的动态冒险、时序连续性和亚稳态等）。
  
.. TBD 动态冒险示例，cb + /c/a 当 a=0, b=1 且 c=1->0（只要动态行为在时钟周期结束前稳定，我们就不关心）
  
- 最低层的门：电路设计视角停留在逻辑门。数字设计师很少需要从晶体管和其他存在于硅片上的电路元件的角度来思考。与使用二进制逻辑类似，门级抽象简化了对电路功能的推理。

- 静态时序分析通过为每个延迟限定最小/最大值，然后考虑最快和最慢的时序路径来构建一个保守的、最坏情况的时序模型，从而从连续的信号延迟频谱中进行抽象。
  
  静态时序还通过将时序路径终止在时序元件的边界来简化分析，因此假设只有从源触发器到汇触发器的路径，中间只有组合逻辑。这将整个系统时序抽象为孤立的、离散的触发器到触发器路径的分析。

本讨论的唯一目的是让您理解，静态时序分析是一组巧妙的简化，将电路时序过于复杂的现实压缩成一个枯燥的数学练习。然而，这些简化足够保守（有时过于保守），以保证电路的正确功能，至少在其时序方面。

触发器
..........

虽然在分立设计实践中存在许多类型的时序门，但在数字设计中，我们只限于两种类型：D锁存器和D触发器。这源于用HDL语言描述数字电路的期望，以及可以从这种描述中提取的语义。

*D型锁存器*（或简称*D锁存器*）是一种具有透明态和稳定态的时序元件，由*门控*信号``G``（或反向的*使能*信号）控制。在透明状态下，锁存器不断地将数据输入``D``传播到数据输出``Q``。在稳定状态下，数据输出在门控"关闭"之前保持最后一个数据输入值。下图显示了D锁存器操作的示例；为简单起见，我们忽略了任何传播延迟。

.. figure:: png/d_latch.png

   D型锁存器（原理图、符号和示例波形）。

D锁存器功能可以用以下HDL代码描述。

.. code-block:: SystemVerilog

  // Verilog语法
  always @(D or G) begin
      if (G)
          Q <= D;
  end
  
  // SystemVerilog语法
  always_latch begin
      if (G)
          Q <= D;
  end

锁存器的问题在于透明模式。在透明模式下，从``Q``到``D``的反相组合环路将开始振荡，其频率与通过该环路的累积传播延迟成比例（见下图）。此外，透明模式下的锁存器序列将创建跨越一个或多个时序元件的组合（或异步）路径。因此，使用D锁存器需要仔细的设计实践，其中后续锁存器级使用相互反向的门控信号，并且不允许到同一级锁存器的组合路径（包括环路）。

.. figure:: png/latch_oscillator.png

   由于通过锁存器的反相反馈引起的振荡。

*D型触发器*（或简称*D触发器*、*FF*或简称*触发器*）是一种时序元件，其中数据输入``D``在时钟信号``CK``的上升沿事件时复制到数据输出``Q``。其实现通常建立在一系列D锁存器上，称为*主*锁存器和*从*锁存器，具有反向的门控控制，使得每个``CK``半周期只有一个锁存器是透明的，另一个是稳定的。因此，向*有效沿*方向的时钟转换将数据从输入"倾倒"到输出，并将其"锁定"在那里，直到下一个时钟有效沿。触发器功能（忽略门延迟）和等效的HDL代码如下所示。

.. figure:: png/d_flop.png

   D型触发器（原理图、符号和示例波形）。

.. code-block:: SystemVerilog

    // SystemVerilog语法（Verilog只使用`always @(...)`）
    always_ff @(posedge CK) begin
        Q <= D;
    end

触发器在单个、独特的时刻*捕获*输入值的事实使得触发器的使用极其简单。组合环路不再重要，我们可以无限制地连接触发器。因此，*触发器构成了对时钟敏感的同步设计的基础*。

触发器时序参数
....................

与其他门一样，触发器由具有非零响应时间的晶体管构成。这使得触发器经历捕获输入数据并将其发布到数据输出所需的延迟。这些延迟引出了三个核心时序参数：*传播延迟*、*建立时间*和*保持时间*。

.. figure:: png/flop_timing_waveform.png

   显示触发器核心时序参数的波形图。

传播时间（Tp）
  这是从时钟有效沿到捕获的数据出现在数据输出的时间。

建立时间（Ts）
  这是在时钟有效沿之前，数据输入需要稳定以便可靠捕获的最晚时间。

保持时间（Th）
  这是在时钟有效沿之后，数据输入需要保持稳定以便可靠捕获的最短时间。

传播时间与时钟沿后从锁存器变为透明时的延迟有关。建立时间和保持时间与稳定主锁存器结构有关，因此对接收器的正确功能至关重要。

换句话说，建立时间和保持时间定义了时钟有效沿周围的一个窗口，数据输入必须绝对稳定。违反此要求可能导致意外情况，即数据输入未被捕获（即数据输出保留其先前的值），或者更糟糕的是，可能变得亚稳态（参见 `亚稳态`_）。因此，建立时间和保持时间要求奠定了数字电路时序的基础，如果我们过度简化，这是静态时序分析的唯一目的。

.. 提及复位撤销和恢复作为建立/保持的等效项

亚稳态
...............

亚稳态是一个微妙而复杂的主题，要充分理解它，请务必阅读 [Golson2014]_。
我们这里的描述是简化的，以便让读者理解其对时序假设的影响。

在详细讨论之前，请将静态时序分析视为一种检查数据从源触发器到汇触发器的方法，确保数据在保持时间之后足够晚到达，但在汇触发器的建立时间之前足够早到达。此检查计算信号通过源和汇之间所有门所需的时间，这个时间包括源触发器的传播时间。

在正常条件下，将源触发器的输出从一个逻辑电平翻转到另一个逻辑电平需要其传播时间Tp。当源触发器的建立时间或保持时间被违反时，该触发器可能进入*亚稳态*。在这种状态下，触发器的内部电路（即其主锁存器或从锁存器的反相器环路）在逻辑电平之间翻转时，会在稳定的边缘停止，其下一个状态无法预测；它要么完成翻转，要么回落到先前的逻辑状态。另一个麻烦的方面是，最终状态的解析将比传播时间更长，而且同样，那个时间无法预测。

为了帮助您更好地想象正在发生的事情，请考虑下图作为触发器的机械类比：
一个球和一座山（来源 [Golson2014]_，引用自 [Wakerly87]_）。在山的每一侧，球都处于稳定状态，左或右，逻辑0或逻辑1。翻转触发器就像将球"踢"上山。在建立/保持窗口之外稳定触发器的输入就像用力踢，让球越过山顶并落在另一侧，处于另一个逻辑状态。当进入建立/保持窗口并接近时钟沿时，踢的力度减小；接近时钟沿时，踢的力度太弱，球甚至无法到达山顶（即落回原地，触发器不翻转）。在中间某处，会有一个踢的力度使球到达山顶并在那里保持平衡，直到它最终落在这一侧或另一侧；这模拟了亚稳态事件。正如您可以想象的，球可能会在那里平衡很长时间；肯定比用"强"的翻转踢要长。

.. figure:: png/metastability_mechanical_analogy.png

   亚稳态机械类比 ([Golson2014]_ 和 [Wakerly87]_)。

下图（来源 [Golson2014]_，引用自 [ChaneyMolnar73]_）显示了亚稳态在实践中如何在触发器的输出``Q``（及其反向``/Q``）上表现出来。模糊区域显示了许多解析及其所需的时间。

.. figure:: png/metastability_flop_output_trace.png

   亚稳态触发器输出的示波器跟踪 ([Golson2014]_ 和 [ChaneyMolnar73]_)。

现在我们解释亚稳态和建立/保持时间究竟如何相互关联。下图显示了一个图表，其中水平轴表示触发器时钟和数据输入变化之间的时间；左侧数据输入变化在时钟事件之前，右侧反之。垂直轴表示翻转触发器所需的时间。在足够远的左侧和右侧，``Q``输出以恒定延迟翻转。我们让数据变化越接近时钟事件（即图表原点0处），翻转所需的时间就越长，直到达到某些界限，翻转永远不会发生（即垂直渐近线之间的"数据未被捕获"区域）。接近渐近线时，翻转时间呈指数增长，您可能已经猜到，渐近线代表了亚稳态。

.. figure:: png/flop_characterization_plot.png

   触发器传播时间作为数据和时钟输入变化之间时间延迟的函数。

在表征触发器的时序参数时，会运行模拟以确定类似的图表。``CK``到``Q``的时间被限制在其最低值的某个百分比（例如加10%），这就成了传播时间。图表与传播限制相交的``CK``到``D``的时间成为建立/保持时间（左侧/右侧）。如您所见，建立时间和保持时间与实际的亚稳态区域保持一定距离，这就是为什么它们在建立/保持稳定窗口之外保证正确功能的原因。您还可能注意到，除非您的设计处于建立/保持时间的边缘，否则实际的触发器传播延迟将小于表征的传播时间。

为了结束这个简短的探讨，请记住以下几点：

- 触发器的时序参数被确定为足够小或足够大以避免亚稳态。
- 将``D``输入更改得太接近时钟有效沿，以至于建立或保持时间被违反

  a. 可能导致触发器的下一个逻辑状态不可预测，并且
  b. 将导致到``Q``的传播延迟超过传播时间（从而使我们对静态时序分析的假设无效）。

.. note:: 选择用一组离散时序参数来表示和约束触发器的翻转功能是数字设计为简化其任务而采用的抽象之一。如您所知，时序参数是保守地推导出来的，因此没有静态时序 violations 的设计将处于保证正确操作的安全侧。

静态时序分析
----------------------

*静态时序分析*（STA）的目标是确保设计中所有触发器（或一般的时序元件）都能安全地捕获其数据。换句话说，STA确保电路将正确执行其功能（但它不涉及该功能的正确性；为此有逻辑仿真）。

术语
..........

理解STA中使用的术语对于理解STA本身至关重要。我们从解释基本术语开始；其他术语将在我们学习更高级时序方面时出现。在解释术语的同时，我们还建立了STA概念的基础。

单元、门、网络
  *单元*或*门*是电路中的组合或时序逻辑元件。电路中的单元通过导线/*网络*连接。

时序弧、单元弧、网络弧
  *时序弧*是与逻辑元件/门或网络/线延迟相关的时序参数。门时序参数，
  *单元弧*，来自该门功能的时序表征（例如，参见 `亚稳态`_ 以了解FF表征的示例）。
  网络延迟，*网络弧*，表示信号通过该网络从驱动器传播到接收器所需的时间。它是信号*转换*和该网络RC参数（包括网络上所有接收器的电容）的函数。
  
  *单元弧*与该门的输入-输出和/或输入-输入对相关联。输入-输出对弧通常表示从该输入到该输出的信号传播延迟（例如，触发器的Tp表示时钟沿后下一个触发器状态出现在输出上需要多长时间）。输入-输入对弧通常表示与这些输入相关的*时序约束*（例如，触发器的Ts约束时钟沿之前数据输入稳定的最晚时间）。并非所有输入-输入和输入-输出对都需要与时序弧相关联；这种关联源于该门的功能。
  
.. figure:: png/cell_arcs.png

   触发器单元弧的示例（包括由于异步复位``RB``引起的额外弧）和组合单元。

信号路径
  从一个*单元*到另一个*单元*的*信号路径*是通过*网络*和其他*单元*的唯一路径，方向为逻辑信号传播方向。

时序路径
  *时序路径*是从*起点*到*终点*的一组信号路径，见下图。
  路径的方向是逻辑信号可以走的方向（即通过路径上逻辑元件的输入到输出）。
  
  设计中的并非每个点都可以是*起点*或*终点*（参见后面）。因此，设计中*时序路径*的集合是有限的。通常*时序路径*在时序元件中开始和结束，并且只通过组合逻辑。
  
  *时序路径*可以分解为一系列*时序弧*，路径延迟成为这些弧的总和。
  
  对于给定的*起点*和*终点*对，因此也就是*时序路径*，可以有多个*信号路径*，逻辑信号可以通过这些路径传播。这是由信号通过路径上逻辑元件的并行时序弧的分支和重组引起的。
    
  对于每个*时序路径*，STA引擎找到最快（*早*）和最慢（*晚*）的传播延迟。对于给定的*时序路径*，*早*和*晚路径*可以是相同或不同的信号路径。

.. figure:: png/timing_path.png

   分解为时序弧的时序路径示例。

.. figure:: png/parallel_timing_paths.png

   时序路径的并行信号路径示例。

路径类型
  我们可以根据不同的属性对*时序路径*进行分类，例如沿路径传播的信号类型或路径产生的*时序检查*类型，或路径经过的设计元件。您可能会遇到以下分类：
  
  - 按信号类型或时序检查：*数据路径*、*时钟路径*、*时钟门控路径*、*异步路径*。
  
    - *数据路径*在时序元件的同步数据输入结束。数据路径用于*建立/保持检查*或等效的*时序检查*。
      
    - *时钟路径*在触发器的时钟输入结束。时钟路径不是我们直接对其执行*时序检查*的*时序路径*；它用作检查其他路径类型的补充路径。
      
    - *时钟门控路径*在时钟门控*单元*结束，用于时钟门控建立和保持检查。
      
    - *异步路径*在触发器的异步输入（如置位或清零/复位）结束。
    
  - 按路径点：*输入到寄存器*、*寄存器到寄存器*、*寄存器到输出*、*输入到输出*。
    
    这种分类对于*数据路径*最常见，因为它们产生电路中的大部分时序检查。

.. figure:: png/signal_type_paths.png

   按信号或时序检查类型划分的路径类型。

起点、终点
  *起点*和*终点*是电路中信号变化开始和结束的点。"变化结束"被认为是在当前时钟周期内消耗信号变化。显然，*时序路径*的起点和终点之间必须有一条*信号路径*。
  
  *起点*可以是主输入端口或时序元件的时钟引脚。
  
  *终点*可以是主输出端口或时序元件的数据输入。

.. figure:: png/datapath_types.png

   不同类型的数据路径、起点和终点。

From、To、Through
  在指定*时序路径*时，我们使用路径经过的电路中的点的标识。
  因此*from*和*to*标识路径的*起点*和*终点*，*through*用于标识中间点。该点可以是引脚名称或单元名称（或有时是层次块名称），只要它能唯一标识路径；使用引脚是最具体的标识。
  
  *from*和*to*用于标识单条路径或一组路径。*through*通常用于在多条并行*信号路径*中选择一条。这些指定符通常用于STA工具中报告时序或指定高级时序约束。

.. figure:: png/from-through-to_points.png

   *from*、*through*和*to*点的图示。
  
启动时钟、捕获时钟
  *启动时钟*是在*时序路径*的*起点*启动/*触发*信号变化的时钟源。
  
  *捕获时钟*是在*时序路径*的*终点*采样/*捕获*信号变化的时钟源。
  
  对于给定的*时序路径*，*启动*和*捕获时钟*可以具有相同或不同的起源。至于产生数据*启动*和*捕获*的时钟有效沿，它们可能相同，也可能不同。

.. 图中的启动/捕获时钟示例

路径延迟
  *路径延迟*只是沿该路径的*时序弧*延迟的总和。对于信号路径，弧系列是唯一的。*时序路径*延迟是其信号路径之一的延迟，由我们分析的属性选择（例如*早*或*晚*路径）。
  
  *单元延迟*通常是输入信号转换/转换时间和单元输出负载的函数。*网络延迟*是RC参数的函数。因此，路径延迟通常基于相同的参数而变化。

约束
  *时序约束*是驱动静态时序分析的动力，因为它们确定了电路时序被认为正确的界限。约束来自两个来源：技术库和用户。
  
  技术约束，如建立/保持时间、最小脉冲宽度、最大电容或最大转换时间，是在库单元表征期间确定的。这些约束被视为特定技术和单元库的给定条件。
  
  用户定义的约束定义了用户对电路时序的假设，包括时钟周期、时钟波形、为电路输入和输出定义的裕量及其驱动和负载特性等内容。用户约束通常定义某些时序例外（例如恒定的信号或应忽略分析的设计部分）并模拟真实系统中通常出现的时序变化（例如时钟抖动或片上参数变化）。
  
  用户还可以覆盖技术库中的约束，无论是用于调试目的还是为了模拟某些非常特定的方面。有时其他工具可用于确定单元特定的约束或网络延迟，其结果以标准格式被反标到正在分析时序的电路中。

时序检查、建立检查、保持检查
  *时序检查*是静态时序分析的核心，检查给定的*时序路径*是否满足与其相关的所有*约束*。例如，从一个触发器到另一个触发器的数据路径被检查为具有不违反目标触发器建立/保持时间的传播延迟。
  
  事实上，建立和保持检查是STA中最频繁的检查。其他检查验证时钟和复位输入的最小脉冲宽度、异步置位/清零输入的恢复和撤销时间、数据到数据时序等。有些检查不一定涉及时序，例如单元最大负载。
  
  *建立检查*和*保持检查*强制执行时序单元的数据建立和保持。*建立检查*测试数据是否足够早地在*捕获时钟*有效沿之前到达，以不违反捕获元件的建立时间。
  类似地，*保持检查*测试数据是否在*捕获时钟*有效沿之后足够长时间地变化，以不违反捕获元件的保持时间。见下图。
  
  建立和保持检查是核心的*时序检查*，许多其他需要测试的时序方面都会转换为这两个检查（例如最小/最大数据延迟）。

.. figure:: png/setup_hold_checks.png

   建立和保持检查的原理。请注意，每个检查都考虑启动和捕获时序的最坏情况组合。

数据到达、数据需求
  如果您考虑*寄存器到寄存器*时序路径，则*数据到达*是启动触发器的数据变化到达捕获触发器输入的时间。*数据需求*是*捕获时钟*沿到达捕获触发器时钟输入的时间，根据该触发器的数据*时序约束*（即建立或保持时间）进行调整。
  
  由于数据变化由*启动时钟*触发，*数据到达*时间包括*启动时钟*传播到启动触发器时钟输入的延迟以及触发器到触发器的数据传播延迟。在上图中，*数据到达*是五个时序弧的总和，三个*网络弧*（td1、td3、td5）和两个*单元弧*（td2、td4）。
  
  数据捕获由*捕获时钟*触发，因此由该时钟传播时间（tc2）表示。可靠的捕获受建立/保持时间（tc2）[#]_的约束，因此这些弧必须被计算在内（减去/加上）以获得最晚/最早的*需求*数据到达。回想一下*建立检查*；它测试从一个时钟沿到另一个时钟沿的数据传播，因此其*数据需求*也计入了时钟周期。*保持检查*在同一时钟沿之间，因此没有周期时间。
  
  *数据到达*和*数据需求*建立了时序检查的条件：对于*建立检查*，数据应较早到达，对于*保持检查*，数据应较晚到达（比*需求*）。然而，还有更多内容。由于各种原因，*数据*和*时钟路径*上的延迟会波动[#]_。STA需要保守，因此它使用产生最坏情况的*早*和*晚*路径组合。因此*建立检查*将*晚*数据到达与*早*数据需求进行比较，反之亦然对于*保持检查*。
  
  现在从*寄存器到寄存器*路径类型中抽象出来，您可以为*起点*和*终点*的任何组合定义*到达*和*需求*时间。您还可以将该概念推广到任何类型的时钟触发*时序检查*，例如恢复/撤销或最小/最大路径延迟。
  
.. [#] 请注意，图中弧的方向表示该弧是增加/减去（同向/反向）到总路径延迟。
   
.. [#] 您将在后面的练习中看到。*起点*和*终点*之间可以有多条并行*信号路径*，每条路径都有不同的延迟。*单元弧*延迟可能随信号极性而变化。可能存在时钟不确定性、信号转换变化等。
  
裕量
  *裕量*是避免违反*约束*的时间量。
  
  在*时序检查*计算中，裕量通常计算为*数据需求*时间减去*数据到达*时间（即``slack = Trequire - Tarrive``）。在保持检查的情况下，当保持约束满足时，这个差值将为负（参见上图）。然而，根据定义，负*裕量*表示违规，因此保持裕量报告为裕量公式结果的负值。

示例
........

本节旨在实践整个`术语`_部分介绍的STA基础知识。它由一系列练习组成，复杂度逐渐增加（就STA概念而言）。建议您先自己尝试练习，然后再阅读记录的解决方案。

在每个练习中，目标和任务用*斜体*排版。解决方案和其他评论用正常字体排版。

在所有练习中，我们**将网络视为理想的**，因此忽略它们的延迟。

练习1：简单的触发器到触发器路径
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*目标：练习建立和保持检查的计算。介绍到达和需求时间计算的典型列表。*

.. figure:: png/circ01.png

   练习1电路。

*任务：对于图中的FF1到FF2时序路径：*

- *识别FF1到FF2时序路径的起点和终点。*
- *计算启动和捕获时钟时序。*
- *计算建立和保持裕量。* 

根据定义，起点是``FF1/CK``，终点是``FF2/D``。启动和捕获时钟是``FF1/CK``和``FF2/CK``，都源自``clk``。时钟周期为20纳秒，默认时钟波形如下图所示。由此，建立和保持启动沿在时间``T=0纳秒``。建立检查测试数据是否比下一个捕获沿更早到达，因此建立捕获沿在``T=Tclk=20纳秒``。保持检查测试数据是否比同一捕获沿更晚到达，因此保持捕获沿在``T=0纳秒``。

.. figure:: png/default_same_edge_timing.png

   显示默认启动和捕获时序。

现在计算裕量，我们需要确定*数据到达*和*数据需求*时间并计算它们的差值。我们通常以表格形式显示计算，*到达*在前，*需求*在后；*裕量*最后出现。我们使用三列：时序点、延迟增量和总延迟。时序点标识时序弧，其值表示延迟增量。总延迟只是沿路径累积增量。

对于我们的示例，建立裕量计算如下::

    点             增量   总延迟
    clk (上升)          0        0
    FF1/CK              3        3
    G1/A                2        5
    FF2/D               0        5
    数据到达                  5
    
    clk (上升)          0       20
    FF2/CK              0       20
    FF2 建立          -0.7     19.3
    数据需求               19.3
    
    裕量 (需求 - 到达)   14.3 > 0  => 建立检查通过

类似地计算保持裕量::

    点             增量   总延迟
    clk (上升)          0        0
    FF1/CK              3        3
    G1/A                2        5
    FF2/D               0        5
    数据到达                  5
    
    clk (上升)          0        0
    FF2/CK              0        0
    FF2 保持            0.3      0.3
    数据需求                0.3
    
    裕量 (需求 - 到达)   -4.7 < 0  => 保持检查通过

练习2：负沿时钟的影响
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*目标：讨论并展示在时序路径中混合具有不同沿敏感性的触发器的效果。*

.. figure:: png/circ02.png

   练习2电路。

*任务：对于FF1到FF2时序路径：*

- *计算启动和捕获时钟时序。*
- *计算建立和保持裕量。* 

与`练习1：简单的触发器到触发器路径`_的唯一区别是FF2在下降沿触发。这会影响*启动时间*和*捕获时间*。对于*建立检查*，数据在``FF1/CK``上升沿启动，在下一个``FF2/CK``下降沿捕获。因此，对于启动时间``T=0纳秒``，捕获时间是``T=10纳秒``。

::

    点             增量   总延迟
    clk (上升)          0        0
    FF1/CK              3        3
    G1/A                2        5
    FF2/D               0        5
    数据到达                  5
    
    clk (下降)          0       10
    FF2/CK              0       10
    FF2 建立          -0.7      9.3
    数据需求                9.3
    
    裕量 (需求 - 到达)    4.3 > 0  => 建立检查通过

对于保持检查，我们测试由``FF1/CK``上升沿启动的数据是否不会被最近的先前捕获时钟（即``FF2/CK``下降沿）捕获。因此，对于在``T=0纳秒``的启动，最近的先前捕获将是``T=-10纳秒``。STA避免启动和捕获时序中的负值，因此我们将设置移动一个时钟周期，得到在``T=20纳秒``和``T=10纳秒``的启动和捕获。

::

    点             增量   总延迟
    clk (上升)          0       20
    FF1/CK              3       23
    G1/A                2       25
    FF2/D               0       25
    数据到达                 25
    
    clk (上升)          0       10
    FF2/CK              0       10
    FF2 保持            0.3     10.3
    数据需求               10.3
    
    裕量 (需求 - 到达)  -14.7 < 0  => 保持检查通过

现在考虑相反的情况，当启动时钟在下降沿触发，捕获时钟在上升沿触发时。启动/捕获时间将如何变化？建立/保持裕量将如何变化？下图将两种情况进行了对比。

.. note:: 在连续触发器级中混合相反沿触发的触发器有助于以增加建立时序裕量为代价来增加保持时序裕量。这种技术通常出现在不使用STA技术的模拟设计师中（典型的同沿数字设计）。它也是串行接口协议中的常见做法（例如I2C、SPI、JTAG）。这种做法的重要性将在`练习4：并行触发器到触发器路径`_中解释。

.. figure:: png/opposite_edge_timing.png

   显示相反沿触发触发器对建立和保持检查的影响。

练习3：带时钟树的简单触发器到触发器路径
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*目标：练习时钟路径中存在单元时的建立/保持裕量计算。思考修复时序违规的可能性。*

.. figure:: png/circ03.png

   练习3电路。

*任务：对于FF1到FF2时序路径：*

- *计算启动和捕获时钟时序。*
- *计算建立和保持裕量。*
- *思考当G1/A为恒定逻辑0时的情况。*

在前面的练习中，我们使用了没有时钟传播延迟的*理想时钟*。在大多数电路中，时钟信号负载很重，在时钟路径段中插入缓冲器（以防止最大电容违规），创建我们称为*时钟树*的树状结构。插入时钟树会引入时钟路径的延迟，并使时钟事件在不同时间到达不同的触发器。我们称这种差异为*时钟偏斜*。大的时钟偏斜可能是时序违规的来源之一。

在我们的示例中，时钟树中的缓冲器影响启动/捕获时序和最终裕量，如下所示::

    # 建立裕量计算                               # 保持裕量计算
    点             增量   总延迟                          点             增量   总延迟
    clk (上升)          0        0                          clk (上升)          0        0
    B1/A                1        1                          B1/A                1        1
    B2/A                2        3   <-- 启动时间 -->    B2/A                2        3
    FF1/CK              3        6                          FF1/CK              3        6
    G1/B                2        8                          G1/B                2        8
    G2/A                2       10                          G2/A                2       10
    FF2/D               0       10                          FF2/D               0       10
    数据到达                 10                          数据到达                 10
    
    clk (上升)          0        7                          clk (上升)          0        0
    B1/A                1        8                          B1/A                1        1
    B3/A                2       10   <-- 捕获时间 -->   B3/A                2        3
    FF2/CK              0       10                          FF2/CK              0        3
    FF2 建立          -0.7      9.3                        FF2 保持            0.3      3.3
    数据需求                9.3                        数据需求                3.3
    
    裕量 (需求 - 到达)   -0.7 < 0 (!!!)              裕量 (需求 - 到达)   -6.7 < 0
    => 建立检查失败                                   => 保持检查通过

如我们所见，电路经历了建立时间违规。以下是我们修复它的方法；由于我们缺少0.7纳秒的建立时间，并且在保持上有额外的6.7纳秒裕量，理论上修复是可能的。

- 通过以下一种或组合来减少*数据到达*时间：

  - 减少启动时钟延迟（例如移除B2缓冲器；请注意，移除B1不会有帮助，因为它也出现在*需求*路径中），或
  - 减少数据路径延迟（例如通过移除G2并将G1更改为AND门）和/或选择更快的单元（包括FF1）。
    
- 通过以下方式增加*数据需求*时间：

  - 增加*到达*时钟路径段唯一的时钟路径段的延迟（例如在B2之后添加更多时钟缓冲器），或
  - 减少捕获触发器FF2的建立时间（即选择更快的单元），或
  - 增加周期时间（例如选择``Tclk=8纳秒``将使建立裕量为0.3纳秒）。

在上述选项中，通过单元缩放或减少组合逻辑（或应用其他重定时技术）来减少数据路径延迟是首选方法。操作时钟路径更加复杂，因为它可能对*到*FF1和*从*FF2的路径时序产生负面影响；因此，在不知道其时序裕量的情况下，我们无法确定不会引入比解决的问题更多的问题。

.. note:: 重要的是要理解，如果所有其他方法都失败了，您总是可以通过放宽周期时间来修复建立时间违规。

到目前为止，我们考虑了``G1/A``由某些任意逻辑驱动的情况。当我们有恒定的``G1/A=0``时，情况会如何变化？

显然，G1是一个NAND门，因此其输出将变为恒定的``G1/Y=1``，并且该恒定值最终将传播到``FF2/D``。从时序的角度来看，路径将变为恒定，因此是一条*无效路径*。

练习4：并行触发器到触发器路径
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*目标：在存在从起点到终点的多条路径时练习时序分析。思考修复时序违规的可能性。*

.. figure:: png/circ04.png

   练习4电路。

*任务：对于FF1到FF2时序路径：*

- *计算启动和捕获时钟时序。*
- *计算建立和保持裕量。*

本示例中的新方面是存在从``FF1/CK``到``FF2/D``的多条数据路径，我们需要确定*最晚*和*最早*的路径。在我们案例中的两条路径中，通过G1的路径显然比通过G2的另一条路径更长。因此，我们使用前者进行建立检查，使用后者进行保持检查。

::

    # 建立裕量计算                               # 保持裕量计算
    点             增量   总延迟                          点             增量   总延迟
    clk (上升)          0        0   <-- 启动时间 -->    clk (上升)          0        0
    FF1/CK              0        0                          FF1/CK              0        0
    G1/B                2        2                          G2/B                1        1
    G3/A                2        4                          FF2/D               0        1
    FF2/D               0        4                          数据到达                  1
    数据到达                  4
    
    clk (上升)          0        7                          clk (上升)          0        0
    FF2/CK              0        7                          FF2/CK              0        0
    FF2 建立          -0.7      6.3                        FF2 保持            0.3      0.3
    数据需求                6.3                        数据需求                0.3
    
    裕量 (需求 - 到达)    2.3 > 0  => 建立检查通过        裕量 (需求 - 到达)   -0.7 < 0 (!!!)
                                                         => 保持检查失败

我们看到电路经历了保持时间违规。以下是我们修复它的方法；由于我们缺少0.7纳秒的保持时间，并且在建立上有额外的2.3纳秒裕量，修复应该是可能的。

- 通过以下一种或组合来增加*数据到达*时间：

  - 增加启动时钟延迟（例如添加更多缓冲器），或
  - 增加数据路径延迟（例如通过插入缓冲器）。
    
- 通过以下方式减少*数据需求*时间：

  - 减少捕获时钟路径延迟（如果存在该路径段唯一的延迟），或
  - 增加捕获触发器FF2的保持时间（即选择更慢的单元）。

修复保持违规比修复建立违规更棘手。我们无法通过放宽周期时间来解决它。插入缓冲器来解决保持问题可能会在其他路径上引起建立问题。

.. note:: 注意，此示例显示了时钟偏斜的后果。在`练习3：带时钟树的简单触发器到触发器路径`_中，我们有7纳秒的时钟偏斜，这是建立违规的主要来源。在本练习中，我们显示了零时钟偏斜，保持违规是由并行数据路径引起的。在现实设计中，时钟偏斜通常是保持问题的主要来源，而建立问题通常源于长组合路径。

练习5：考虑转换的最坏情况路径选择
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*目标：显示信号转换如何影响最坏情况路径选择。介绍最快/最慢转换的概念。*

.. figure:: png/circ05.png

   练习5电路。

*任务：对于FF1到FF2时序路径：*

- *解释为什么路径选择取决于信号转换。*
- *计算建立和保持裕量。*

本练习中的新方面涉及单元延迟如何随输入信号转换而变化，以及这如何影响最坏情况路径选择。

单元延迟取决于输入转换和输出负载。通常，输入信号的转换越快（边沿越陡），通过单元的传播延迟就越短。相反，较慢的输入转换会导致较长的传播延迟。

在我们的电路中， NAND门G1和G2具有不同的输入转换时间：
- G1由FF1驱动，其输出转换可能较慢
- G2由G1的输出驱动，其转换时间取决于G1的延迟

这种依赖关系创建了一个场景，其中路径延迟不是静态的，而是取决于转换特性。建立检查（晚路径）需要选择总延迟最长的路径，而保持检查（早路径）需要选择总延迟最短的路径。

基于这些考虑，我们可以计算裕量。对于建立检查，我们假设最坏情况（慢转换），对于保持检查，我们假设最好情况（快转换）：

::

    # 建立裕量计算（最坏情况 - 慢转换）
    点             增量   总延迟
    clk (上升)          0        0
    FF1/CK              0        0
    G1/B              0.5      0.5  <- 慢转换输入
    G3/A              0.6      1.1
    FF2/D               0      1.1
    数据到达                1.1
    
    clk (上升)          0        7
    FF2/CK              0        7
    FF2 建立          -0.7      6.3
    数据需求                6.3
    
    裕量 (需求 - 到达)    5.2 > 0  => 建立检查通过
    
    # 保持裕量计算（最好情况 - 快转换）
    点             增量   总延迟
    clk (上升)          0        0
    FF1/CK              0        0
    G2/B              0.3      0.3  <- 快转换输入
    FF2/D               0      0.3
    数据到达                0.3
    
    clk (上升)          0        0
    FF2/CK              0        0
    FF2 保持            0.3      0.3
    数据需求                0.3
    
    裕量 (需求 - 到达)    0.0 = 0  => 保持检查勉强通过

这个练习说明了STA必须考虑转换变化以准确确定最坏情况时序路径。

练习6：最小和最大延迟约束
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*目标：练习数据路径的最小和最大延迟约束计算。*

.. figure:: png/circ06.png

   练习6电路。

*任务：对于FF1到FF2时序路径：*

- *计算路径的最小和最大延迟。*
- *验证这些约束是否满足。*

时序约束可以指定数据路径必须满足的最小和最大延迟。这些约束通常用于接口时序，其中必须满足外部建立和保持要求。

最大延迟约束确保数据不会花费太长时间从启动触发器传播到捕获触发器。这本质上等同于建立检查。

最小延迟约束确保数据保持稳定足够长的时间，以满足捕获触发器的保持要求。这等同于保持检查。

在我们的示例中，让我们假设以下约束：
- 最大延迟：5纳秒
- 最小延迟：1纳秒

计算实际路径延迟：

::

    # 路径延迟计算
    点             增量   总延迟
    FF1/CK              0        0
    G1/A                2        2
    G2/B                2        4
    FF2/D               0        4
    总路径延迟                  4纳秒

验证约束：
- 最大延迟：4纳秒 ≤ 5纳秒 => 满足
- 最小延迟：4纳秒 ≥ 1纳秒 => 满足

两种约束都满足，路径符合指定的时序要求。

.. note:: 在实践中，最小和最大延迟约束通常用于约束输入和输出延迟，其中时序路径的一部分在设计外部（例如，在PCB或外部存储器上）。

练习7：多周期路径
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*目标：理解和计算多周期路径的时序。*

.. figure:: png/circ07.png

   练习7电路。

*任务：对于FF1到FF2时序路径：*

- *解释为什么这是一个多周期路径。*
- *计算正确的建立和保持检查。*

多周期路径是一种数据需要多个时钟周期才能从启动触发器传播到捕获触发器的时序路径。当设计包含需要多个周期来产生结果的复杂组合逻辑，或者当信号被时钟使能门控，有效地降低采样率时，就会出现这种情况。

在我们示例中，路径通过启用信号``EN``进行门控，该信号每两个周期断言一次。这实际上意味着数据只需要每两个时钟周期被捕获一次。

对于多周期路径，建立检查被修改以考虑额外的周期时间：

::

    # 建立检查（2周期路径）
    启动沿：T=0纳秒
    捕获沿：T=40纳秒（2个周期 × 20纳秒）
    
    点             增量   总延迟
    clk (上升)          0        0
    FF1/CK              0        0
    G1/B                2        2
    G2/A (EN=1)         2        4
    FF2/D               0        4
    数据到达                  4
    
    clk (上升)          0       40
    FF2/CK              0       40
    FF2 建立          -0.7     39.3
    数据需求               39.3
    
    裕量                 35.3 >> 0  => 建立检查轻松通过

对于保持检查，我们仍然使用与启动沿相同的捕获沿（或根据具体设计约束使用前一个有效捕获沿）：

::

    # 保持检查
    启动沿：T=0纳秒
    捕获沿：T=0纳秒（或T=20纳秒，取决于约束）
    
    点             增量   总延迟
    clk (上升)          0        0
    FF1/CK              0        0
    G1/B                2        2
    FF2/D               0        2
    数据到达                  2
    
    clk (上升)          0        0
    FF2/CK              0        0
    FF2 保持            0.3      0.3
    数据需求                0.3
    
    裕量 (需求 - 到达)   -1.7 < 0  => 保持检查通过

.. note:: 必须将多周期路径约束告知STA工具，以防止工具错误地报告违规。通常，这通过指定路径所需周期数的特殊时序约束来完成。

练习8：半周期路径
~~~~~~~~~~~~~~~~~~~~~~~~~~

*目标：练习半周期（相反沿）时序路径的分析。*

.. figure:: png/circ08.png

   练习8电路。

*任务：对于FF1到FF2时序路径：*

- *确定这是半周期路径。*
- *计算建立和保持裕量。*

半周期路径发生在启动触发器在时钟的一个沿（例如上升沿）触发，而捕获触发器在相反沿（例如下降沿）触发时。这有效地将可用于数据传输的时间减半。

在我们的示例中：
- FF1在上升沿启动（正沿触发器）
- FF2在下降沿捕获（负沿触发器）

时钟周期为20纳秒，因此半周期为10纳秒。

建立检查计算：

::

    # 建立裕量计算（半周期路径）
    启动沿：T=0纳秒（上升沿）
    捕获沿：T=10纳秒（下降沿）
    
    点             增量   总延迟
    clk (上升)          0        0
    FF1/CK              0        0
    G1/A                2        2
    G2/B                2        4
    FF2/D               0        4
    数据到达                  4
    
    clk (下降)          0       10
    FF2/CK              0       10
    FF2 建立          -0.7      9.3
    数据需求                9.3
    
    裕量 (需求 - 到达)    5.3 > 0  => 建立检查通过

对于保持检查，我们必须确保由上升沿启动的数据不会被前一个下降沿捕获（或根据具体设计约束使用前一个有效捕获沿）：

::

    # 保持裕量计算
    启动沿：T=0纳秒（上升沿）
    捕获沿：T=-10纳秒（前一个下降沿）=> 调整为T=10纳秒和T=20纳秒
    
    点             增量   总延迟
    clk (上升)          0       20
    FF1/CK              0       20
    G1/A                2       22
    G2/B                2       24
    FF2/D               0       24
    数据到达                 24
    
    clk (上升)          0       10
    FF2/CK              0       10
    FF2 保持            0.3     10.3
    数据需求               10.3
    
    裕量 (需求 - 到达)  -13.7 < 0  => 保持检查通过

半周期路径通常用于高频设计，其中需要在时钟的两个沿捕获数据，有效地使数据速率相对于时钟频率加倍。

.. note:: 半周期路径对建立时间有更严格的要求（只有半个周期可用），但通常提供更大的保持时间裕量。这在高速接口中经常被利用。

练习9：虚假路径
~~~~~~~~~~~~~~~~~~~~~

*目标：识别和理解设计中的虚假路径。*

.. figure:: png/circ09.png

   练习9电路。

*任务：对于FF1到FF2时序路径：*

- *识别虚假路径。*
- *解释为什么它是虚假的。*
- *确定正确的时序分析。*

虚假路径是一种由于逻辑功能或设计操作而无法在电路正常操作期间 sensitized（激活）的时序路径。在STA中分析虚假路径会导致过度约束和可能错误的违规报告。

在我们的示例中，考虑从FF1通过G1和G2到FF2的路径。然而，仔细观察逻辑：

- G1是一个AND门，输入为A和B
- G2是一个NAND门，输入为G1的输出和信号C
- 当控制信号CTRL为逻辑0时，FF1的输出被强制为逻辑1

分析路径 sensitization：

1. 当CTRL = 0时，FF1输出恒定为1
2. 这意味着通过G1和G2的路径不能传播切换
3. 因此，当CTRL = 0时，从FF1到FF2的路径是虚假的

在STA中，我们应该使用虚假路径约束将此路径声明为虚假：

::

    # 虚假路径声明（伪约束语法）
    set_false_path -from FF1/CK -to FF2/D -when {CTRL == 0}

通过将路径声明为虚假，STA工具将不会对其进行时序分析，从而避免虚假违规报告。

.. note:: 识别虚假路径需要理解设计的功能。通常，虚假路径发生在：
   - 路径被逻辑条件阻塞（如本例所示）
   - 路径在正常操作期间从未被使用（例如测试模式路径）
   - 路径跨越异步时钟域而没有适当的同步
   - 路径被设计架构排除（例如互斥控制信号）

练习10：时钟门控检查
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

*目标：理解和计算时钟门控建立和保持检查。*

.. figure:: png/circ10.png

   练习10电路。

*任务：对于时钟门控单元CG1：*

- *识别时钟门控路径。*
- *计算时钟门控建立和保持裕量。*

时钟门控是一种用于通过禁用时钟信号来降低功耗的技术，当触发器或触发器组不需要切换时。门控信号必须在时钟沿之前和之后稳定，以确保正确的时钟脉冲传输。

在我们的示例中：
- CLK是主时钟信号
- EN是门控使能信号
- CG1是时钟门控单元（通常是AND或OR门，或专门的集成时钟门控单元ICG）
- 门控时钟GCLK驱动FF2

时钟门控检查确保使能信号在时钟沿周围正确建立和保持：

::

    # 时钟门控建立检查
    点             增量   总延迟
    clk (上升)          0        0
    FF1/CK              0        0
    G1/A                1        1
    CG1/EN              0        1
    EN到达                    1
    
    clk (上升)          0        0
    CG1/CLK             0        0
    CG1 建立          -0.5     -0.5
    EN需求                   -0.5
    
    裕量                 -1.5 < 0  => 建立检查失败
    
    # 时钟门控保持检查
    点             增量   总延迟
    clk (上升)          0        0
    FF1/CK              0        0
    G1/A                1        1
    CG1/EN              0        1
    EN到达                    1
    
    clk (上升)          0        0
    CG1/CLK             0        0
    CG1 保持            0.2      0.2
    EN需求                    0.2
    
    裕量 (需求 - 到达)   -0.8 < 0  => 保持检查通过

在这个例子中，我们看到时钟门控建立检查失败。这可能通过以下方式修复：
- 在EN路径中添加延迟（例如，添加缓冲器）
- 使用时钟沿更早触发的触发器来驱动EN
- 使用具有更宽松建立时间要求的专用集成时钟门控单元

.. note:: 时钟门控检查对于低功耗设计至关重要。未能正确约束时钟门控可能导致毛刺时钟或功能故障。

结论
--------

本课程涵盖了静态时序分析的基础知识，包括：

- 数字电路抽象和时序分析基础
- 触发器类型（锁存器和触发器）及其时序参数
- 亚稳态及其对时序的影响
- 核心STA概念：路径、约束、检查和裕量
- 通过实际练习的实践示例

理解这些概念对于任何从事数字电路设计和验证的工程师都是必不可少的。静态时序分析是确保集成电路正确时序行为的基本工具，正确的应用需要理解本课程中介绍的理论基础和实践考虑。

参考文献
-----------

.. [Golson2014] Steve Golson, "Metastability - What it is, What it is not, and How to live with it", 2014.
.. [Wakerly87] John F. Wakerly, "Digital Design: Principles and Practices", Prentice Hall, 1987.
.. [ChaneyMolnar73] T. J. Chaney and C. E. Molnar, "Anomalous Behavior of Synchronizer and Arbiter Circuits", IEEE Transactions on Computers, Vol. C-22, No. 4, April 1973.
